---
title: "Advanced Topics in Network Analysis 1: Centrality, Group Detection, Small Worlds and Simulation"
author: "Mark Hoffman"
output: html_document
---
# Centrality

In this tutorial, we look at measures of network centrality, which we use to identify structurally important actors. We also discuss possible ideas for identifying important edges. 

Centrality originally referred to how central actors are in a network's structure. It has become abstracted as a term from its topological origins and now refers very generally to how important actors are to a network. Topological centrality has a clear definition, but many operationalizations. Network "importance" on the other hand has many definitions _and_ many operationalizations. We will explore the possible meanings and operationalizations of centrality here. There are four well-known centrality measures: degree, betweenness, closeness and eigenvector - each with its own strengths and weaknesses. The main point we want to make is that the analytical usefulness of each depends heavily on the context of the network, the type of relation being analyzed and the underlying network morphology. We don't want to leave you with the impression that one is better than another - only that one might serve your research goals better than another.

Every node-level measure has its graph-level analogue. Centralization measures the extent to which the ties of a given network are concentrated on a single actor or group of actors. We can also look at the degree distribution.  It is a simple histogram of degree, which tells you whether the network is highly unequal or not.

### Loading the example network

As always, we need to load igraph.

```{r}
library(igraph)
```

The dataset we are loading is called padgett_marriage.csv 

It is a subset of a famous dataset collected by John Padgett on the relationships of prominent Florentine families in 15th century Italy. The historical puzzle is that the Medici, an upstart family, seizes political power in 1434. Padgett's goal was to explain how the Medici rose to power. 

He looked at many relations, but we only have the marriage here. Marriage was a tool in diplomacy, central to political alliances. A tie is drawn between families if the daughter of one family was sent to marry the son of another. 

Ron Breiger has argued these edges should be directed, tracing where daughters were sent, but we will analyze with the symmetrized (undirected) version. That is, we don't differentiate between whether a son or daughter being sent from each family.

As always, we first load and prepare the dataset. This time however we will load in the .csv files directly from the internet. We can put any direct web link to a .csv file in the read.csv function, and it will load the file.
```{r}
florentine_edgelist <- read.csv("http://www.markanthonyhoffman.com/downloads/florentine_edgelist.csv", stringsAsFactors = FALSE, row.names = 1)

florentine_attributes <- read.csv("http://www.markanthonyhoffman.com/downloads/florentine_attributes.csv", stringsAsFactors = FALSE)

marriageNet <- graph_from_data_frame(d = florentine_edgelist, directed = F, vertices = florentine_attributes)
marriageNet = simplify(marriageNet)
```

Let's see how it looks.

```{r}
plot(marriageNet, vertex.size = 2, vertex.label.cex = .4, vertex.label.color = "black", vertex.color = "tomato")
```

Based on this plot, which family do you expect is most central?

### Degree Centrality

The simplest measure of centrality is degree centrality. It counts how many edges each node has - the most degree central actor is the one with the most ties. 

> **Note:** In a directed network, you will need to specify if in or out ties should be counted. These will be referred to as in or out degree respectively. If both are counted, then it is just called degree

Degree centrality is calculated using the degree function in R. It returns how many edges each node has.

```{r}
degree(marriageNet) 
```

Who is the most degree central? 

We can assign the output to a variable in the network and size the nodes according to degree.

```{r}
V(marriageNet)$degree <- degree(marriageNet) # assignment

plot(marriageNet, vertex.label.cex = .6, vertex.label.color = "black", vertex.size = V(marriageNet)$degree) # sized by degree
```

The problem is that the degree values are a little small to plot well. We can use a scalar to increase the value of the degree but maintain the ratio.

```{r}
plot(marriageNet, 
     vertex.label.cex = .6, 
     vertex.label.color = "black", 
     vertex.size = V(marriageNet)$degree*3)
```

### Betweenness Centrality

Betweenness centrality captures which nodes are important in the flow of the network. It makes use of the shortest paths in the network. A path is a series of adjacent nodes. For any two nodes we can find the shortest path between them, that is, the path with the least amount of total steps (or edges). If a node C is on a shortest path between A and B, then it means C is important to the efficient flow of goods between A and B.  Without C, flows would have to take a longer route to get from A to B. 

Thus, betweenness effectively counts how many shortest paths each node is on. The higher a node's betweenness, the more important they are for the efficient flow of goods in a network.

In igraph, betweenness() computes betweenness in the network

```{r}
betweenness(marriageNet, directed = FALSE)
```

We can again assign the output of betweenness() to a variable in the network and size the nodes according to it.

```{r}
V(marriageNet)$betweenness <- betweenness(marriageNet) # assignment

plot(marriageNet, 
     vertex.label.cex = .6, 
     vertex.label.color = "black", 
     vertex.size = V(marriageNet)$betweenness) # sized by betweenness
```

Betweenness centrality can be very large. It is often helpful to normalize it by dividing by the maximum and multiplying by some scalar when plotting. 

```{r}
plot(marriageNet,
     vertex.label.cex = .6, 
     vertex.label.color = "black", 
     vertex.size = V(marriageNet)$betweenness/max(V(marriageNet)$betweenness) * 20)
```

### Closeness Centrality

With closeness centrality we again make use of the shortest paths between nodes. We measure the distance between two nodes as the length of the shortest path between them. Farness, for a given node, is the average distance from that node to all other nodes.
Closeness is then the reciprocal of farness (1/farness).

```{r}
closeness(marriageNet)
```

We assign it to a node variable and plot the network, adjusting node size by closeness.

```{r}
V(marriageNet)$closeness <- closeness(marriageNet)
```

```{r}
plot(marriageNet,
     vertex.label.cex = .6, 
     vertex.label.color = "black", 
     vertex.size = V(marriageNet)$closeness/max(V(marriageNet)$closeness) * 20)
```

## Eigenvector Centrality

Degree centrality only takes into account the number of edges for each node, but it leaves out information about ego's alters.

However, we might think that power comes from being tied to powerful people. If A and B have the same degree centrality, but A is tied to all high degree people and B is tied to all low degree people, then intuitively we want to see A with a higher score than B. 

Eigenvector centrality takes into account alters' power. It is calculated a little bit differently in igraph. It produces a list object and we need to extract only the vector of centrality values.

```{r}
evcent(marriageNet)$vector
```

Then we can assign that vector to our network and plot it.

```{r}
V(marriageNet)$eigenvector <- evcent(marriageNet)$vector

plot(marriageNet,
     vertex.label.cex = .6, 
     vertex.label.color = "black", 
     vertex.size = V(marriageNet)$eigenvector/max(V(marriageNet)$eigenvector) * 20)
```

### Measure Correlations

Most of these measures are highly correlated, meaning they don't necessarily capture unique aspects of pwoer. However, the amount of correlation depends on the network structure. Let's see how the correlations between centrality measures looks in the Florentine Family network. cor.test(x,y) performs a simple correlation test between two vectors.

```{r}
cor.test(V(marriageNet)$degree, V(marriageNet)$betweenness)
cor.test(V(marriageNet)$degree, V(marriageNet)$eigenvector) 
cor.test(V(marriageNet)$degree, V(marriageNet)$closeness)
cor.test(V(marriageNet)$betweenness, V(marriageNet)$eigenvector)
cor.test(V(marriageNet)$betweenness, V(marriageNet)$closeness)
```

What do we learn?

### Centralization and Degree Distributions

To understand the measures further, we can look at their distributions. This will tell us roughly how many nodes have centralities of a given value.

```{r}
hist(V(marriageNet)$betweenness, xlab = "Betweenness", main = "Degree distribution of betweenness")
```





We can see that most nodes in the marriage network have low betweenness centrality, and only one node has more than 40 betweenness. Degree distributions tend to be right-skewed; that is, only a few nodes in most networks have most of the ties. Evenly distributed degree is much rarer.

Finally centralization measures the extent to which a network is centered around a single node. The closer a network gets to looking like a star, the more centralization will be. 

```{r}
centralization.degree(marriageNet)
centralization.betweenness(marriageNet)
centralization.evcent(marriageNet)
centralization.closeness(marriageNet)
```

