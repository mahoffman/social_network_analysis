[
["index.html", "Social Network Analysis Welcome", " Social Network Analysis Peter Bearman and Mark Hoffman Welcome Peter Bearman psb17@columbia.edu Mark Hoffman Mh3279@columbia.edu This seminar is intended as a theoretical and methodological introduction to social network analysis. Though network analysis is an interdisciplinary endeavor, its roots can be found in classical anthropology and sociology. Network analysis focuses on patterns of relations between actors. Both relations and actors can be defined in many ways, depending on the substantive area of inquiry. For example, network analysis has been used to study the structure of affective links between persons, flows of commodities between organizations, shared members between social movement organizations, and shared needles between drug users. What is central is an emphasis on the structure of relationality, which serves to link micro- and macro-level processes. We will spend this course becoming familiar with the theoretical foundations of structural network analysis, including principles of balance and transitivity, the implications of connectivity and density, the relationship between categories and networks, the nature of exchange structures, and power and centrality. We will also discuss substantive applications of the network approach. Each class covers substantive and theoretical material and is associated with a technical lab. You will need to bring your laptops to each class. In the technical labs you will learn how to analyze network data in R. This e-book contains all of the technical labs, in the order that we will cover them. Should you forget anything we learned, you will be to return to this book and go through the tutorial again. In addition, at the end of each chapter is a list of readings, which pertain to the theoretical and methodological topics discussed in each class. We start with the basics: installing R and R Studio, creating and loading network data structures into R and plotting networks and network aesthetics. We then analyze networks using descriptive statistics, including size, density, reciprocity, transitivity, centrality, assortativity and modularity. Next we discuss bipartite graphs and their analysis. We conclude with network simulation and modeling. "],
["readings-for-the-course.html", "1 Readings for the course 1.1 Day 1: Introduction to types of networks and strategies for analysis (Articles we discussed) 1.2 Day 2: Part 1 – Ego-Networks 1.3 Day 2 – Part 2 Balance and Transitivity 1.4 Day 3: Part 1 Centrality 1.5 Day 3: Part 2. Modularity, Community Structure and Small Worlds 1.6 Day 4: Part 1, Rectangular Matrices 1.7 Day 4: Part 2 Blockmodeling Multiple Relations", " 1 Readings for the course 1.1 Day 1: Introduction to types of networks and strategies for analysis (Articles we discussed) Bearman, Peter, James Moody and Katherine Stovel. 2003. “Chains of Affection.” American Journal of Sociology. 110:44-91. Erikson, Emily and Peter Bearman. “Malfeasance and the Foundations for Global Trade: The Structure of English Trade in the East Indies, 1601-1833.” American Journal of Sociology. 112(1): 195-230. Bearman, Peter and Katherine Stovel. 2000. “Becoming a Nazi.” Poetics 27:69-90. Bearman, Peter, Robert Faris, and James Moody. “Blocking the Future: New Solutions for Old Problems in Historical Social Science.” Social Science History. 23(4): 501-533 Hoffman, Mark, JP Cointet, Phiipp Brandt, Newton E. Key, and Peter Bearman. “The (Protestant) Bible, the (Printed) Sermon, and the Word(s): The Semantic Structure of the Conformist and Dissenting Bible, 1660-1780.” Poetics. (Forthcoming). 1.2 Day 2: Part 1 – Ego-Networks McPherson, Miller, Lynn Smith-Lovin, and Matthew E. Brashears. 2006. “Social isolation in America: Changes in Core Discussion Networks over Two Decades.” American Sociological Review. 71:353-375. Fischer, Claude S. 2009. “Comment: The 2004 GSS Finding of Shrunken Social Networks: An Artifact?.” American Sociological Review. 74:657-669. McPherson, Miller, Lynn Smith-Lovin, and Matthew E. Brashears. 2009. “Reply: Models and Marginals: Using Survey Evidence to Study Social Networks.” American Sociological Review. 74:670-681. Bearman, Peter and Paolo Parigi. 2004. “Cloning Headless Frogs and Other Important Matters: Conversation Topics and Network Structure.” Social Forces. 83:535-557. Lee, BK and Peter Bearman. “Important Matters in Political Context”. Sociological Science. 1.3 Day 2 – Part 2 Balance and Transitivity Chase, Ivan. 1980. “Social Process and hierarchy formation in small groups: comparative perspective.” American Sociological Review. 45:905-924. Johnson, Eugene. 1985. “Network Macrostructure Models for the Davis-Leinhardt set of empirical sociomatricies.” Social Networks. 7. Balian, Hrag and Peter Bearman. “Pathways to Violence: Dynamics for the Continuation of Large-Scale Conflict”. Sociological Theory. (Forthcoming) 1.4 Day 3: Part 1 Centrality Bonacich, Phillip. 1987 “Power and Centrality: A Family of Measures”. American Journal of Sociology. 92:1170-118. Granovetter, Mark S. 1973. “The Strength of Weak Ties.” American Journal of Sociology. 78:1360-1380. 1.5 Day 3: Part 2. Modularity, Community Structure and Small Worlds Shwed, Uri and Peter S. Bearman. “The Temporal Structure of Scientific Consensus Formation.” American Sociological Review. 75(6): 817-840. Travers, Jeffrey and Stanley Milgram. 1969. “An experimental study of the small world Problem.” Sociometry. 32:425-443 Watts, Duncan J. 1999. “Networks, Dynamics, and the Small-World Phenomenon.” American Journal of Sociology. 105:493-527. 1.6 Day 4: Part 1, Rectangular Matrices Bearman, Peter. 1991. “The social structure of suicide”. Sociological Forum. 6:501-524. Rytina, Steve and David L. Morgan.1982. “The arithmetic of social relations: The interplay of category and network.” American Journal of Sociology. 88:88-113. Bearman, Peter S and Kevin D. Everett. “The Structure of Social Protest, 1961-1983.” Social Networks. 15(2): 171-200. 1.7 Day 4: Part 2 Blockmodeling Multiple Relations White, Harrison, Scott Boorman, and Ronald Breiger. 1976. “Social Structure from multiple networks. I. Blockmodels of roles and positions.” American Journal of Sociology. 81:730-779. Bearman, Peter. 1997. “Generalized Exchange.” American Journal of Sociology. 102:1383-1415. "],
["installing-r-and-rstudio.html", "2 Installing R and RStudio 2.1 Downloading and Installing R 2.2 Downloading and Installing RStudio", " 2 Installing R and RStudio In this section, we will learn how to install R and RStudio. Both are freely available online. 2.1 Downloading and Installing R Description R is an open source programming language designed for statistical computing and visualization. Scientists and data analysts worldwide use it for purposes ranging from regression analysis, to natural language processing, to biological simulation, to social network analysis - the topic of this class. Being open source, users from around the world add new functions to its repositories on a daily basis. This means that the possible tools you can use and analyses you can perform with R are expanding constantly, making it an increasingly powerful environment for statistical analysis. We will show you just a glimpse of this power, but hopefully we can provide enough of a basis for you to go out on your own and learn more. Steps Navigate to https://www.r-project.org/ Click on the blue, bolded “download R” in the first paragraph. Choose a mirror (in other words, a website hosting current and past R distributions) located somewhere near to you. I am based in New York so I chose one based out of Carnegie Mellon in Pennsylvania. Download R by clicking on one of the “Download R for” links. Choose the link that accords with your operating system. I am using Mac, so I clicked: “Download R for (Mac) OS X” Next click the first link underneath the “Files” heading. This should begin the download. Follow the instructions on the installer that begins when you click on the downloaded file. Once you are finished, R should be installed on your system. 2.2 Downloading and Installing RStudio Description Next we need to install RStudio. RStudio is a user interface for R, which greatly improves the experience of working in R. As stated on its website, some of its features include: Customizable workbench with all of the tools required to work with R in one place (console, source, plots, workspace, help, history, etc.). Syntax highlighting editor with code completion. Execute code directly from the source editor (line, selection, or file). Full support for authoring Sweave and TeX documents. Runs on all major platforms (Windows, Mac, and Linux) and can also be run as a server, enabling multiple users to access the RStudio IDE using a web browser. Steps To download RStudio, navigate to https://www.rstudio.com/ and click the download RStudio button: Scroll down and click on the green “Download” button in the RStudio Desktop column. RStudio is free! This should cause your browser to scroll down to the bottom of the page where you will see a series of blue installers. Click the installer (not Zip/Tarball!) according to your operating system. This should prompt a download. Double click on the downloaded file, which will begin the installation process. If you are on Mac OS X, drag RStudio to your Applications folder. Now you are all set to go for the tutorial! Find RStudio wherever you saved it (Applications folder if you are on Mac), and open it. In the next chapter, we will learn what to do once it is up and running. "],
["tour-rstudio-with-udacity.html", "3 Tour RStudio with Udacity", " 3 Tour RStudio with Udacity Now that RStudio is open watch the Udacity video below to learn more about the interface and how to use it. Once you finish, we will begin programming in R. "],
["r-basics.html", "4 R Basics 4.1 Vectors, matrices and data.frames 4.2 Indexing and Subsetting 4.3 Loading Packages", " 4 R Basics This initial tutorial for R has two primary learning objectives. The first is to become affiliated with the R environment and the second is to learn how to extend the basic set of R functions to make it suitable for your own research purposes. The lessons we learn in this tutorial will serve as a strong basis for the those that follow, which focus on the actual analysis of networks using R. Like most programming languages, R can serve as a calculator. We will use many of these basic mathematical operations when working with network data. 2+2 ## [1] 4 ((2+2)*3)/6 ## [1] 2 2^2 ## [1] 4 We use the assignment operator “&lt;-” to save the results in a vector for later. four &lt;- 2+2 sixteen &lt;- (2+2)^2 If we type the name of the vector, it will return its values. four ## [1] 4 sixteen ## [1] 16 Functions in R also have names. Later on, we will learn to write our own functions. For now, we can make use of the large body of default functions that exist within R. The most basic function is print. We can use it to output text in the console. print(&quot;Hello world!&quot;) ## [1] &quot;Hello world!&quot; log() is another useful function and it has two arguments, x and base. When you call the function log() you have to specify x (the input value), while base has a default of exp(1). log82 &lt;- log(x = 8, base = 2) If you don’t specify the arguments in their correct order, you must use argument=value form or else you will get a different result. log1 &lt;- log(8, base = 2) log2 &lt;- log(x = 8, base = 2) log3 &lt;- log(8, 2) log4 &lt;- log(base = 2, x = 8) log5 &lt;- log(2, 8) The cat function concatenates the R objects and prints them. cat(log1, log2, log3, log4, log5) ## 3 3 3 3 0.3333333 As you can see, the fifth specification of the logarithm returned different results. 4.1 Vectors, matrices and data.frames Vectors are the most basic object in R. They contain ordered elements of the same type. Vectors of size &gt; 1 are created using the “c” function. v &lt;- c(0,1,2,3,4,5,6,7,8,9) print(v) ## [1] 0 1 2 3 4 5 6 7 8 9 Computations on vectors are performed element-wise. v &lt;- v * 3 print(v) ## [1] 0 3 6 9 12 15 18 21 24 27 Matrices can be created using the matrix function. I specify what I want in each cell of the matrix and the dimensions of the matrix. This will make a square 5 by 5 matrix with all zeroes. If the argument “byrow” is TRUE, the matrix will be filled row by row (horizontally). Otherwise, it will be filled by column (vertically). zero &lt;- rep(0,5) # the rep function replicates the values in x a given number of times one &lt;- rep(1,5) matrix_data &lt;- matrix(c(zero,one,zero,one,zero), nrow = 5, ncol = 5, byrow = TRUE) matrix_data ## [,1] [,2] [,3] [,4] [,5] ## [1,] 0 0 0 0 0 ## [2,] 1 1 1 1 1 ## [3,] 0 0 0 0 0 ## [4,] 1 1 1 1 1 ## [5,] 0 0 0 0 0 matrix_data &lt;- matrix(c(zero,one,zero,one,zero), nrow = 5, ncol = 5, byrow = FALSE) matrix_data ## [,1] [,2] [,3] [,4] [,5] ## [1,] 0 1 0 1 0 ## [2,] 0 1 0 1 0 ## [3,] 0 1 0 1 0 ## [4,] 0 1 0 1 0 ## [5,] 0 1 0 1 0 Using the sample function, we can fill each cell randomly with either 0 or 1. This simulates an adjacency matrix for a network where connections between people are random. matrix_data2 &lt;- matrix(sample(c(1,0), 25, replace = TRUE, prob=c(.5,.5)), nrow=5, ncol=5, byrow =TRUE) matrix_data2 ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 1 0 0 1 ## [2,] 1 0 0 0 1 ## [3,] 1 1 0 0 1 ## [4,] 1 1 1 0 0 ## [5,] 1 0 1 1 1 Finally, using dimnames, we can name each dimension, which makes sense given we are working with “social” networks. matrix_data3 &lt;- matrix(sample(c(1,0), 25, replace = TRUE, prob=c(.5,.5)), nrow=5, ncol=5, byrow =TRUE, dimnames = list(c(&quot;Thea&quot;, &quot;Pravin&quot;, &quot;Troy&quot;, &quot;Albin&quot;, &quot;Clementine&quot;), c(&quot;Thea&quot;, &quot;Pravin&quot;, &quot;Troy&quot;, &quot;Albin&quot;, &quot;Clementine&quot;))) matrix_data3 ## Thea Pravin Troy Albin Clementine ## Thea 0 0 0 0 0 ## Pravin 1 1 1 1 1 ## Troy 0 1 0 1 0 ## Albin 1 1 0 0 1 ## Clementine 1 1 0 1 0 We can convert a matrix into a data.frame and vice versa. The class() function tells us what type of object we are working with. matrix_data3 &lt;- as.matrix(matrix_data3) class(matrix_data3) ## [1] &quot;matrix&quot; matrix_data3 &lt;- as.data.frame(matrix_data3) class(matrix_data3) ## [1] &quot;data.frame&quot; Data frames behave like a Stata dataset, for those that are familiar. However, they are inefficient in R and are increasingly being replaced by user-created data classes, such as data.table. In this class, we will deal primarily with matrices, but if you use regression analysis it will be worth your time to explore data.frames. 4.2 Indexing and Subsetting When we are working with a matrix or data.frame, we might want to access or manipulate a single row or column at a time. To do so, we need to index a row or column. This can be done in two ways. If we are working with a data.frame, we can use the $ operator. The name of the column we wish to access follows the dollar sign. matrix_data3$Thea will return the column values for Thea. matrix_data3 ## Thea Pravin Troy Albin Clementine ## Thea 0 0 0 0 0 ## Pravin 1 1 1 1 1 ## Troy 0 1 0 1 0 ## Albin 1 1 0 0 1 ## Clementine 1 1 0 1 0 matrix_data3$Thea ## [1] 0 1 0 1 1 We can then manipulate the column directly matrix_data3$Thea &lt;- 1 matrix_data3 ## Thea Pravin Troy Albin Clementine ## Thea 1 0 0 0 0 ## Pravin 1 1 1 1 1 ## Troy 1 1 0 1 0 ## Albin 1 1 0 0 1 ## Clementine 1 1 0 1 0 We can also use subscripting. For example, matrix_data3[,1] tells R to return the first column while matrix_data3[1,] tells R to return the first row. Finally, matrix_data3[1,1] is the cell located in the first row of the first column. This is more flexible than $, but requires you to know the locations of the intended data in the dataset or matrix. matrix_data3[,1] ## [1] 1 1 1 1 1 matrix_data3[1,] ## Thea Pravin Troy Albin Clementine ## Thea 1 0 0 0 0 matrix_data3[1,1] ## [1] 1 Vectors are also indexed, but they only have one dimension, so no comma is needed. trial_vector &lt;- c(1,2,3,4,5,6) trial_vector[1] ## [1] 1 Finally, we may wish to remove columns in a data.frame, matrix or vector. We can use the subset function to do this. trial_vector &lt;- subset( trial_vector, trial_vector &gt; 2) trial_vector ## [1] 3 4 5 6 We can perform this same operation with subscripts trial_vector &lt;- c(1,2,3,4,5,6) trial_vector &lt;- trial_vector[trial_vector &gt; 2] In effect, they both say - take a subset of trial_vector in which the value in the vector is greater than 2 Finally we can use the subscript index method to change values if they meet a certain criteria trial_vector &lt;- c(1,2,3,4,5,6) trial_vector[trial_vector &gt; 2] &lt;- 10 trial_vector ## [1] 1 2 10 10 10 10 We won’t use subset with matrices, but we will likely index them. Subsetting is more commonly used with data.frames 4.3 Loading Packages Packages are collections of R functions, data, and compiled code. They are built by members of the R community to add functionality to base R. Generally, if you wish you could do something with R, someone has built a package to do it already! We will use a few packages, some of which are built into R. We will need to install the others. For now, we just need to install igraph, which is the most developed network analysis package for R. To do so, we use the install.packages() function. # install.packages(&quot;igraph&quot;) The library function tells R to add the package to the current R session library(igraph) ## ## Attaching package: &#39;igraph&#39; ## The following objects are masked from &#39;package:stats&#39;: ## ## decompose, spectrum ## The following object is masked from &#39;package:base&#39;: ## ## union We will use the library() function every time we start a new R session. If R cannot find a function that you are sure is in a package you use, it normally means the package isn’t loaded or that you somehow misspelled the function name. "],
["understanding-network-data-structures.html", "5 Understanding network data structures 5.1 Edge lists 5.2 Adjacency matrices", " 5 Understanding network data structures Underlying every network visualization is data about relationships. These relationships can be observed or simulated (that is, hypothetical). When analyzing a set of relationships, we will generally use one of two different data structures: edge lists or adjacency matrices. 5.1 Edge lists One simple way to represent a graph is to list the edges, which we will refer to as an edge list. For each edge, we just list who that edge is incident on. Edge lists are therefore two column matrices that directly tell the computer which actors are tied for each edge. In a directed graph, the actors in column A are the sources of edges, and the actors in Column B receive the tie. In an undirected graph, order doesn’t matter. In R, we can create an example edge list using vectors and data.frames. I specify each column of the edge list with vectors and then assign them as the columns of a data.frame. We can use this to visualize what an edge list should look like. personA &lt;- c(&quot;Mark&quot;, &quot;Mark&quot;, &quot;Peter&quot;, &quot;Peter&quot;, &quot;Bob&quot;, &quot;Jill&quot;) personB &lt;- c(&quot;Peter&quot;, &quot;Jill&quot;, &quot;Bob&quot;, &quot;Aaron&quot;, &quot;Jill&quot;, &quot;Aaron&quot;) edgelist &lt;- data.frame(PersonA = personA, PersonB = personB, stringsAsFactors = F) print(edgelist) ## PersonA PersonB ## 1 Mark Peter ## 2 Mark Jill ## 3 Peter Bob ## 4 Peter Aaron ## 5 Bob Jill ## 6 Jill Aaron What are the upsides of using the edge list format? As you can see, in an edge list, the number of rows accords to the number of edges in the network since each row details the actors in a specific tie. It is therefore really simple format for recording network data in an excel file or csv file. What are the downsides? The first is practical - it is impossible to represent isolates using an edge list since it details relations. There are ways to get around this problem in R, however. The second is technical - edge lists are not suitable for data formats for performing linear algebraic techniques. As a result, we will almost always convert and edge list into either an adjacency matrix, or into a network object. 5.2 Adjacency matrices Adjacency matrices have one row and one column for each actor in the network. The elements of the matrix can be any number but in most networks, will be either 0 or 1. A matrix element of 1 (or greater) signals that the respective column actor and row actor should be tied in the network. Zero signals that they are not tied. We can use what we learned in the last tutorial to create such a matrix. An example might look like this: adjacency &lt;- matrix(c(0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0), nrow = 5, ncol = 5, dimnames = list(c(&quot;Mark&quot;, &quot;Peter&quot;, &quot;Bob&quot;, &quot;Jill&quot;, &quot;Aaron&quot;), c(&quot;Mark&quot;, &quot;Peter&quot;, &quot;Bob&quot;, &quot;Jill&quot;, &quot;Aaron&quot;))) print(adjacency) ## Mark Peter Bob Jill Aaron ## Mark 0 1 0 1 0 ## Peter 1 0 1 0 1 ## Bob 0 1 0 1 0 ## Jill 1 0 1 0 1 ## Aaron 0 1 0 1 0 What are the upsides of using the adjacency matrix format? Adjacency matrices are the most fundamental network analysis data format. They undergird all of the analytical techniques we will show you later on. They are also much more efficient than edge lists. For example, imagine searching for whether Peter and Jill are friends in an adjacency matrix as opposed to an edge list. In the adjacency matrix, we would go to Peter’s row and Jill’s column and we would find either a 1 or a 0, giving us our answer. In an edge list, we would have to search through each edge, which might seem simple in a dataset with only 5 people, but as the edge list grows, it will scale linearly with the number of edges. What are the downsides? It is really difficult to record network data with an adjacency matrix. They are better suited for computers than people. "],
["your-first-network.html", "6 Your First Network 6.1 Creating a project 6.2 Creating data in Excel 6.3 Saving Excel data as a .csv file 6.4 Loading data into R 6.5 From data to networks 6.6 Exploring your network", " 6 Your First Network In this chapter, we will create our own network data in Excel, learn to load the data into R, and the turn the data into a network object using the igraph package. You can use these steps to begin analyzing data from your own projects. 6.1 Creating a project First let’s create a new R project. RStudio projects allow you to keep your various data analysis projects separate from one another. Each project has its own working directory, workspace, history, and source documents. When you load a project, you will therefore see the work, history and files associated with that project, helping your organize your work. Go to the “File” menu at the top of the screen and click on “New Project…” Then start a new directory. Directories are folders where you keep your R Project and all of the data, files, code etc. that you create and use in the project. Now start an empty project. Projects are created by RStudio and they maintain your R workspace for you, so that you can load it exactly as it was before you closed RStudio. Finally name your project (I named mine “SNA_Tutorial”) and browse to find the location on your computer where you would like it to be saved. We will use this directory to store all of the files and information for the class, so make sure to choose a name you can remember. Now if you navigate to the folder of your new R Project (mine is on my Desktop in the folder titled “SNA Tutorial”, for example), you will see the R Project there, symbolized by a blue glass cube with an R in it. If you ever want to re-open this project, you can double click on the cube. Alternatively, in RStudio you can go “File -&gt; Open Project”, navigate to the project’s directory and open it from there. This folder is where you should keep all of your data and R scripts for this project. Since we just created the project that we will use for the remainder of the tutorials, it is the best place for you to put all future class materials. 6.2 Creating data in Excel Imagine you want to collect some data on your local social network. You might go to each of your friends and ask them to nominate up to five people who are their friends. You then want to load this data into R and graph it as a network. How could you go about doing this? The first step is to record the data in some machine-readable way, either using Excel or Numbers or even in plain text files. Many people, before coming to R, have experience using Excel or some program like it to manage data, whether financial, academic, or otherwise. An Excel worksheet is organized into rows and columns with columns generally containing information of a single kind (say First Names) and rows generally containing the data for a single observation. You can freely input data into any of the cells. An empty Excel spreadsheet The first step in any network analysis project is to create a dataset with the relationships between the people in your study. The easiest way to record relationships in Excel is as an edge list, which, as we discussed in the last section, is a two column matrix that lists the pairs of actors in a relationship. Let’s build an edge list together in Excel. Imagine we want to track patterns of monetary provision in a household (i.e. whether person A gives person B money). We construct an edge list, where column A is the Ego (the money provider) and column B is the Alter (the money taker). We then fill in instances, or relationships, of monetary provision from Ego to Alter. Below is an example: Money providing edge list (Hoffman family) Try recording something similar for your family! 6.3 Saving Excel data as a .csv file Great! Now we need to save this data in a format that R can easily read. I generally use the .csv format, which separates values by commas, because R has a default function for reading .csv files. To save an Excel sheet as a .csv file, in Excel go to “File -&gt; Save As…” Then give your file a name (I chose “money_edgelist”), choose the place where you want to save it (inside of the directory you made for class), and finally (the most important part!), click on the “File Format” dropdown menu and choose “Comma Separated Values (.csv)”. Click “Save”! It will ask will warn you that the workbook contains features that will not work or may be removed if you save it in the selected file format and ask if you want to continue. Click “Continue”. Great! Now, inside of your class directory, you should see a new file titled “money_edgelist” (or whatever you chose to name it). In the following section, we will learn how to read that edge list into R. 6.4 Loading data into R Open up RStudio, make sure you are in your project for class (if not, go to “File -&gt; Open Project”, and selection your project), and open a new R Script by going “File -&gt; New File -&gt; R Script”. Save the empty script and name it “loading_data.R”. Your RStudio should look like this: Now we will write our first line of code together. R has a simple function for loading .csv files: read.csv() To use read.csv, we just tell R the name of the .csv file that we want it to read. It will then look inside the directory for that file. If it can’t find the file - either because you typed the wrong name or you never dragged it to the directory - it will return the following error: Error in file(file, “rt”) : cannot open the connection In addition: Warning message: In file(file, “rt”) : cannot open file ‘money_edgelista.csv’: No such file or directory So sure money_edgelist.csv is in your directory or else the following lines of code won’t work! money_edgelist = read.csv(&quot;money_edgelist.csv&quot;) Now you should see in your Environment pane “money_edgelist” under the “Data” heading. That means you successfully loaded the data into R. You can click on it to see its contents or else run View(money_edgelist) in the console. Cool! We now have our data loaded into R, ready to be turned into a network. 6.5 From data to networks In this class, we will primarily use igraph, a user-maintained package in R, to analyze networks. Installing igraph gives us a bunch of new tools for graphing, analyzing and manipulating networks, that don’t come with base R. The first step then is to install igraph. To install a new package, we use the install.packages() function. It takes a character argument that is the name of the package you wish to install. install.packages(&quot;igraph&quot;, repos=&#39;http://cran.us.r-project.org&#39;) ## ## The downloaded binary packages are in ## /var/folders/k0/_v5yt5b901v5vtff0y7zmgmr0000gn/T//RtmpUH0Rjy/downloaded_packages If you leave out the “repos” argument, it will cause a window to pop up with a list of CRAN mirrors. Then you can choose the repository nearest to you by double clicking on it. Now that igraph is installed, we need to use the library() function to load it into R. You will have to do this every time you open RStudio or switch projects if you wish to make use of igraph’s functions. library(&quot;igraph&quot;) Great! Now we can use all of igraph’s functions. To analyze networks, igraph uses an object class called: “igraph”. We therefore have to convert our edge list, freshly loaded into R, into an igraph object. igraph only takes matrices, so we then have to convert our data.frame (the default class of objects returned by read.csv()) to a matrix. money_edgelist &lt;- as.matrix(money_edgelist) We can now turn the money_edgelist edge list into a network object. The required function is graph.edgelist() and it takes two arguments, the network data (an edge list) and whether the edges are directed or undirected. In this case, because giving money is not necessarily a reciprocal relationship (i.e. just because I give you money, doesn’t mean you necessarily give it back… in fact, the opposite is almost always the case!), the network should be directed. moneyNetwork &lt;- graph.edgelist(money_edgelist, directed=TRUE) A Note on Function Documentation If you want to see more about graph.edgelist() or if you want to see other ways to graph data type, you can type ?graph.edgelist. Entering ? before any function will cause R to bring up documentation on that function. Now we have two objects in our Environment, the money_edgelist and a new networked, called moneyNetwork. Both contain the same information at the moment, but igraph can only make use of the latter. What if my data was in adjacency matrix format? If your data was in adjacency matrix format, then you would use the graph.adjacency() function instead of the graph.edgelist() function. More about the graph.adjacency() function can be read in the function’s help section accessed by typing ?graph.adjacency 6.6 Exploring your network We finally have a network in R! So.. what next? Well we can read a summary of it by typing its name into R. moneyNetwork ## IGRAPH DN-- 6 11 -- ## + attr: name (v/c) ## + edges (vertex names): ## [1] Greg -&gt;Maria Greg -&gt;Mark Greg -&gt;Lexi Greg -&gt;Grace Greg -&gt;Nick ## [6] Maria-&gt;Mark Maria-&gt;Lexi Maria-&gt;Grace Maria-&gt;Nick Mark -&gt;Nick ## [11] Lexi -&gt;Nick The first line - which begins with IGRAPH DN - tells us moneyNetwork is an igraph object and a directed network (DN), with N nodes and E edges. The next line tells us some attributes of the nodes and edges network. At the moment, it only has the attribute “name” for the vertices (v/c). We can look at the values of the “name” attribute with the V()$ function. V(moneyNetwork)$name ## [1] &quot;Greg&quot; &quot;Maria&quot; &quot;Mark&quot; &quot;Lexi&quot; &quot;Grace&quot; &quot;Nick&quot; Finally, the last part gives us a snapshot of the edges present in the network, most of which are omitted. We can visualize the network using the plot() function. plot(moneyNetwork) The default visualization is pretty ugly… In the next section, we will learn how to improve the aesthetics of our network visualizations. "],
["network-visualization-and-aesthetics.html", "7 Network Visualization and Aesthetics 7.1 The Basics 7.2 Layouts 7.3 Adding attributes to a network object 7.4 Plotting based on attributes", " 7 Network Visualization and Aesthetics As social scientists, we want to tell convincing stories about the structure and dynamics of the networks we study. Visualization and statistics are the primary tools at our disposable for conveying these stories. In this tutorial we will learn how to change the aesthetics of our network visualizations. When visualizing networks, there are a number of different elements we can adjust. First, we can change the color, size, shapes and labels of nodes. Second, we can change the color, width, curviture and appearance of edges. We can highlight the location of different groups in the network. Finally, we can manipulate the overall layout of the network. 7.1 The Basics Let’s start by adjusting the basic visualization. First, load in the data we created in the last tutorial and graph it as a network. The code below should look familiar. The only difference is that I converted money_edgelist into a matrix in the same line as graphing it as an edgelist. This is called nesting functions. There is no limit to the amount of functions you can have nested, though often times it is easier to read if you break them up into multiple lines. library(igraph) money_edgelist &lt;- read.csv(&quot;money_edgelist.csv&quot;, stringsAsFactors = F) moneyNetwork &lt;- graph.edgelist(as.matrix(money_edgelist), directed=TRUE) Visualizing the network is as simple as typing plot(moneyNetwork). But as I mentioned earlier, the default plot is really horrible (and it used to be worse…). We can adjust the settings of the plot so that the resulting visualization is more aesthetically pleasing. There are many settings for the igraph plot() function, and we will go over the bare minimum you need to start making decent visualizations on your own. plot(moneyNetwork) The most basic things we can change are the sizes and colors of nodes. When your network is large, often the nodes will appear too large and clumped together. The argument vertex.size allows you to adjust node size (vertex is the graph-theory term for node!). plot(moneyNetwork, vertex.size = 10) This is the basic way you change the settings of the plot function in igraph - you put a comma next to the next to the network object, type the name of the setting you want to change, and set it to a new value. Here we set vertex.size to 10. When you don’t change any settings, R will automatically use the default settings. You can find them in the help section for that function (i.e. by typing ?plot.igraph, for example). All you have to do is remember the names of the various settings, or look them up at: http://igraph.org/r/ The nodes have an ugly light orange color… We can use vertex.color to change their color to something nicer. We can also remove the ugly black frames by changing the vertex.frame.color setting to NA. Useful Link You can find a list of all the named colors in R at http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf plot(moneyNetwork, vertex.size = 10, vertex.color = &quot;tomato&quot;, vertex.frame.color = NA) The labels are too large and blue. We can adjust label size with vertex.label.cex. We can adjust the color with vertex.label.color plot(moneyNetwork, vertex.size = 10, vertex.color = &quot;tomato&quot;, vertex.frame.color = NA, vertex.label.cex = .7, vertex.label.color = &quot;black&quot;) Alternatively, if we want to get rid of the labels, we can just set vertex.label to NA. plot(moneyNetwork, vertex.size = 10, vertex.color = &quot;tomato&quot;, vertex.frame.color = NA, vertex.label = NA) Finally we can make the edges smaller and curved to give them a nicer aesthetic plot(moneyNetwork, vertex.size = 10, vertex.color = &quot;tomato&quot;, vertex.frame.color = NA, vertex.label.cex = .7, vertex.label = NA, edge.curved = .1, edge.arrow.size = .3, edge.width = .7) But don’t go too crazy! If you set edge.curved to be greater than .1, it will start to look like spaghetti. plot(moneyNetwork, vertex.size = 10, vertex.color = &quot;tomato&quot;, vertex.frame.color = NA, vertex.label.cex = .7, vertex.label = NA, edge.curved = 1.7, edge.arrow.size = .3, edge.width = .7) 7.2 Layouts An essential part of a network visualization is its layout, which determines the nodes’ positions in the plot. There are a wide range of layouts that have been developed for social network analysis. They all try to minimize the number of edges that cross, but use different algorithms for achieving this goal. Generally, I use either the Kamada Kawai algorithm or the Fruchterman Reingold algorithm. igraph has set of layout functions which, when passed a network object, return an array of coordinates that can then used when plotting that network. These coordinates should be saved to a separate R object, which is then called within the plot function. They all have the format: layout DOT algorithm name. For example, layout.kamada.kawai() or layout.fruchterman.reingold() Kamada Kawai # first we run the layout function on our graph kamadaLayout &lt;- layout.kamada.kawai(moneyNetwork) # and then we change the default layout setting to equal the layout we generated above plot(moneyNetwork, layout = kamadaLayout, vertex.size = 10, vertex.color = &quot;tomato&quot;, vertex.frame.color = NA, vertex.label.cex = .7, vertex.label = NA, edge.curved = .1, edge.arrow.size = .3, edge.width = .7) Frucherman-Reingold # first we run the layout function on our graph fruchtermanLayout &lt;- layout.fruchterman.reingold(moneyNetwork) # and then we change the default layout setting to equal the layout we generated above plot(moneyNetwork, layout = fruchtermanLayout, vertex.size = 10, vertex.color = &quot;tomato&quot;, vertex.frame.color = NA, vertex.label.cex = .7, vertex.label = NA, edge.curved = .1, edge.arrow.size = .3, edge.width = .7) You can see ?layout_ for more options and details. 7.3 Adding attributes to a network object We can affect any of these aesthetics arbitrarily. You might prefer the way networks look when the edges are curved as opposed to straight for example. However, we often make decisions informed by theories we have about our empirical setting. If we think that race is important to the structure of the network, we might color nodes according to race. If we think both race and gender are important, we could color nodes by race and change the shape of nodes by gender. We could also size nodes according to wealth. We are generally limited to visualizing three attributes of nodes at once (using color, shape and size), though I find that anything more than two (color and size) is difficult to interpret. It follows that, to visualize how attributes are distributed over the nodes of the network, most network projects need two separate datasets. In addition to creating and loading a dataset of relations, which we covered in the previous tutorial, we need a second dataset that details actors’ attributes and we need to add the data to our network. Deciding wich attributes are relevant will depend on the domain and your research question; if you are studying gangs in the southside Chicago, you might record actors’ gang affiliations and residence; if you are interested in the business relationships between Saudi elites, you might record their age and lineage. Let’s return to Excel and build an attribute dataset for our network. This kind of dataset is much more traditional: each row is a person (otherwise known as an observation) and each column accords with some attribute you measured for that person. Here is a picture of an example attribute dataset I made for my family’s money provision network. Hoffman family attributes I saved this attribute dataset as a .csv file inside of my R directory. I will load it into R, just as I did the edgelist in the previous tutorial (all of this should be practiced and familiar! if not, revisit the previous tutorial). attributes &lt;- read.csv(&quot;attribute_df.csv&quot;, stringsAsFactors = F) head(attributes) ## Name Age Gender Role ## 1 Greg 53 Male Father ## 2 Maria 52 Female Mother ## 3 Mark 25 Male Son ## 4 Lexi 23 Female Daughter ## 5 Grace 19 Female Daughter ## 6 Nick 14 Male Son This gives us a data.frame, where each row corresponds to a person and each column corresponds to one attribute of the people in our network, but to use these attributes in igraph, we have to assign them to the nodes in the igraph object (moneyNetwork, that is). Attributes in igraph are assigned to nodes and edges separately. As mentioned in the previous tutorial, vertices are accessed using the V() function while edges are accessed with the E() function. Attributes are then accessed with the dollar sign operator followed by the attribute name. For example, as we showed earlier, V(countrysideNetwork)$name will tell us the names of all of the nodes in the network. To change an attribute, we can just use the equals sign to set them equal to something else. So for example, here I change the names of the nodes in my network # Change the names V(moneyNetwork)$name = c(&quot;Bob&quot;, &quot;Linda&quot;, &quot;Elias&quot;, &quot;Catherine&quot;, &quot;Eloise&quot;, &quot;Pumpkin&quot;) # Print the node names to see that it worked! print(V(moneyNetwork)$name) ## [1] &quot;Bob&quot; &quot;Linda&quot; &quot;Elias&quot; &quot;Catherine&quot; &quot;Eloise&quot; &quot;Pumpkin&quot; At the moment, our network doesn’t have any attributes other than name. If we try to look at the sex of our nodes, we will get NULL as a result. V(moneyNetwork)$gender[1:6] ## NULL We therefore need to attach the attributes from our attribute file to our network. The method for doing can be a bit complicated. If we have an edge list, we can use the _from_data_frame() function instead of graph.edgelist(), and include the attributes file as the vertices argument. For whatever reason, in this case, the edge list needs to be a data.frame, so no need to convert it to a matrix. Also, it is important to note that igraph assumes that the first column is the name column, so make sure that is the case! # Load in the edge list again money_edgelist &lt;- read.csv(&quot;money_edgelist.csv&quot;, stringsAsFactors = F) # Load in the attributes again attributes &lt;- read.csv(&quot;attribute_df.csv&quot;, stringsAsFactors = F) # Put them both in the network. moneyNetwork &lt;- graph_from_data_frame(money_edgelist, directed = T, vertices = attributes) Now, if we look at our network, we will see that there are many more next to attr. moneyNetwork ## IGRAPH DN-- 6 11 -- ## + attr: name (v/c), Age (v/n), Gender (v/c), Role (v/c) ## + edges (vertex names): ## [1] Greg -&gt;Maria Greg -&gt;Mark Greg -&gt;Lexi Greg -&gt;Grace Greg -&gt;Nick ## [6] Maria-&gt;Mark Maria-&gt;Lexi Maria-&gt;Grace Maria-&gt;Nick Mark -&gt;Nick ## [11] Lexi -&gt;Nick We can look at each one with the V()$ function. For example, here is gender. V(moneyNetwork)$Gender ## [1] &quot;Male&quot; &quot;Female&quot; &quot;Male&quot; &quot;Female&quot; &quot;Female&quot; &quot;Male&quot; Awesome! Now the attributes are in the network. 7.4 Plotting based on attributes In the last section, we imported attributal data into our network object, which will allow us to manipulate our network according to nodal attributes. Let’s start by manipulating color according to gender To do this we have to assign colors to people according to their sex. We use the ifelse function. The ifelse() function takes three arguments. The first is a test (something that evaluates to TRUE or FALSE), the second is what to return if the test is TRUE and third is what to return if the test is FALSE. We therefore set up an ifelse function, which tests whether a node’s gender is male, assigning it the color “blue” if TRUE (i.e. if they are a male) and “green” if FALSE (i.e. otherwise/they are a female). Remember that R is case sensitive, so if your gender variable contains “Males” and “Females”, then make sure you put Male or Female (capitalized) in the ifelse statement. V(moneyNetwork)$color &lt;- ifelse(V(moneyNetwork)$Gender == &quot;Male&quot;, &quot;dodgerblue3&quot;,&quot;seagreen&quot;) Now we can replot the network. This time a node’s color will be green or blue depending on their gender. Notice that I didn’t set the vertex.colors inside the plot function this time, since doing so would override the colors we just gave the nodes. plot(moneyNetwork, vertex.size = 10, vertex.frame.color = &quot;black&quot;, vertex.label.cex = .7, vertex.label = NA, edge.curved = .1, edge.arrow.size = .3) Now let’s try role. First, I reset color. There are four roles (Father, Mother, Son, Daughter), so we need a few more ifelse statements to code for all of them. V(moneyNetwork)$color &lt;- NA V(moneyNetwork)$color &lt;- ifelse(V(moneyNetwork)$Role == &quot;Father&quot;, &quot;burlywood1&quot;,&quot;tomato&quot;) V(moneyNetwork)$color &lt;- ifelse(V(moneyNetwork)$Role == &quot;Mother&quot;, &quot;seagreen&quot;, V(moneyNetwork)$color) V(moneyNetwork)$color &lt;- ifelse(V(moneyNetwork)$Role == &quot;Son&quot;, &quot;grey70&quot;, V(moneyNetwork)$color) plot(moneyNetwork,vertex.size = 10, vertex.label.cex = .7, vertex.label = NA, edge.curved = .1, vertex.frame.color = &quot;black&quot;, edge.arrow.size = .3, edge.width = .7, edge.color = &quot;grey30&quot;) Last but not least, let’s adjust the sizes of the nodes so that they reflect differences in age. We can set node size to be 1/5th of the node’s age with the code below. Simple, but effective. It looks like the oldest nodes give to the most people. V(moneyNetwork)$size = V(moneyNetwork)$Age/5 plot(moneyNetwork, vertex.label.cex = .7, vertex.label = NA, edge.curved = .1, vertex.frame.color = &quot;black&quot;, edge.arrow.size = .3, edge.width = .7, edge.color = &quot;grey30&quot;) "],
["measuring-transitivity-and-structural-balance.html", "8 Measuring transitivity and structural balance 8.1 Calculating a triad census 8.2 Generating a random graph for comparison 8.3 Random graphs galore!", " 8 Measuring transitivity and structural balance The main goal of this tutorial is to explain the triad census, how to calculate it in igraph and how to use simulation to estimate the expected triad census result under a null model to use as a basis of comparison in evaluating an observed network. We can break large social networks down into their constituent parts. These constituent parts are referred to as “motifs”. The most basic motif consists of two nodes and is called a dyad. Edges in a network signify the presence or absence of dyadic relations. It follows that a dyad in an undirected network can have two possible structures: connected or disconnected; and four possible structures in a directed network. Density captures, at the macro-level, the proportion of dyads that are present over the possible total number of dyads in the network. We are simply re-framing what we discussed last class, except we are focusing on the configuration of nodes as opposed to edges. Triads consist of three nodes and are therefore more complex than dyads, with more possible arrangements. This becomes clear when you realize an undirected triad consists of three dyads: A and B, B and C, and A and C. In an undirected graph, there are eight possible triads (2^3… sort of obvious given that each dyad can be present or absent and there are three dyads). Of those eight possible triads, four are isomorphic, so that there are four unique triads. In an directed graph, there will be sixteen unique triads (the unique number of motifs in directed graphs is not easily reduced to a functional form). Take Professor Bearman’s paper “Chains of Affection” as an example. He and his colleagues found that the spanning tree network observed in the high school lacked 3, 4 and 5 “cycles”. This is another way of saying there were no complete triads, quadrads or pentrads in the network. If we see a network with very few triads, then we know something about the macro-level structure, just by looking at the frequencies of its constituent parts at the micro-level. The triad census calculates how many triads there are of each type (which, as I just mentioned, in a directed network amounts to 16). If this distribution of triads is different than the distribution in a random network, then it could tell us something about the macro-level structure that we couldn’t observe just by looking at a visualization of the network. 8.1 Calculating a triad census igraph has a built in function for the triad census: triad.census() It takes a network object as an argument and returns the number of each type of triad in the network. First, load in igraph. library(igraph) Next download the network we will analyze (simulated data of an Add Health high school, called Faux Mesa High) and its network attributes by following this link: www.markanthonyhoffman.com/downloads/faux_mesa_files.zip It should download a zipped file to your computer . Unzip it and drag its contents into your R Project folder. Once you have the files in your folder, we can run the code below. It loads the network using the graph.data.frame() function from the previous tutorial. faux_edgelist &lt;- read.csv(&#39;faux_edgelist.csv&#39;, stringsAsFactors = F) faux_attributes &lt;- read.csv(&#39;faux_attributes.csv&#39;, stringsAsFactors = F) fauxNetwork &lt;- graph.data.frame(faux_edgelist, directed = T, vertices = faux_attributes) Let’s plot it to see how it looks! plot(fauxNetwork, vertex.size = 3, vertex.label = NA, edge.curved = .1, vertex.color = &quot;tomato&quot;, edge.arrow.size = .1, edge.width = .5, edge.color = &quot;grey30&quot;) It appears to be pretty clustered, with a few distinct groups. Now we can run the triad.census() function from igraph in order to calculate the triad census. triad.census(fauxNetwork) ## [1] 1374298 40077 0 215 105 153 0 0 ## [9] 62 0 0 0 0 0 0 0 As you can see, it returns 16 different numbers. It uses the M-A-N classification structure: M stands for the number of Mutual ties, A stands for the number of Asymmetric ties, and N stands for the number of Null ties. Mutual means that ego and alter (say A and B) have a mutual relation with each other (A likes B and B likes A). A means that ego and alter have an asymmetric relation with one another, i.e. A likes B but B doesn’t like A… the relation is not reciprocated. Finally, N means that A and B do not have any relation. The image below visualizes the different types of triads possible in a directed graph. ?triad.census also describes these possible types, telling you the order that the triad types are presented in the triad.census() output. 003 for example means there are 0 mutual relation, 0 asymmetric relations and 3 null relations. This triad contains no relations. 201 would mean there are two mutual relations, zero asymmetric relations, and 1 null relation. Of three dyads in the triad, two dyads are in a relation, and one dyad is not. 8.2 Generating a random graph for comparison However, we are generally not interested in pure counts. Like in any statistical analysis, we want to know what distribution we would expect by chance, so that we can see if our distribution is meaningfully different. We can approach this question from two different angles: simulation or mathematical derivation. In both cases, we will utilize random graphs as our null model. In random graphs, the chance that any two dyads are in a relation is determined by chance (i.e. the flip of a coin). This means that the likelihood of observing a given tie is independent from observing a tie between any other dyad. There are a lot of reasons that this is unrealistic.. For example, if A and B are friends and A and C are friends, then we would expect the probability that B and C are friends to be higher. This is a basic feature of most social networks… you are more likely to be friends with your friends friends than with strangers. We therefore might want to factor in this human tendency towards triadic closure into our null model - later in the class I will discuss ways of doing this. However, random graphs have many properties that are mathematically and heuristically useful, which is why they are commonly used as null models. We will try to think of better null structures as class goes on. igraph has a fast and easy function for generating random graphs. ?erdos.renyi.game In an erdos.renyi.graph, each edge has the same probability of being created. We determine the probability and it returns a random graph with a density that equals (in expectation) this probability. random_graph &lt;- erdos.renyi.game(n = vcount(fauxNetwork), p.or.m = graph.density(fauxNetwork), directed = TRUE) # where n is the number of nodes, p.or.m is the probability of drawing an edge, directed is whether the network is directed or not plot(random_graph, vertex.size = 3, vertex.label = NA, edge.curved = .1, vertex.color = &quot;tomato&quot;, edge.arrow.size = .1, edge.width = .5, edge.color = &quot;grey30&quot;) We will look more closely at the properties of random graphs when we focus on simulation in later weeks. For now let’s look at the triad census of this random graph. triad.census(random_graph) ## [1] 1376271 38302 0 91 74 172 0 0 ## [9] 0 0 0 0 0 0 0 0 Most triads are null. This is because edges only have a 5% chance of being drawn. It follows that 95% of the total possible edges are missing. There are not many cases of transitive triads, or even in which all three dyads have a relationship. Thus, the majority of triads are concentrated in the left side of the triad distribution Let’s compare it Faux Mesa High. triad.census(fauxNetwork) ## [1] 1374298 40077 0 215 105 153 0 0 ## [9] 62 0 0 0 0 0 0 0 Which triads are common in Faux Mesa High, but not in the random graph? What might this tell us? 8.3 Random graphs galore! The problem is that we are basing our analysis on a single random graph. But since drawing edges is random, there is a lot of variation in the structure of random graphs, especially when the number of nodes in the graph is small (less than one thousand). So let’s generate one hundred random graphs, and create a distribution of random graph triad censuses and see where our graph lies on that distribution trial &lt;- vector(&quot;list&quot;, 100) # this creates a list with 100 spaces to store things. We will store each result here. for ( i in 1:100 ){ # We repeat our exercise 100 times random_graph &lt;- erdos.renyi.game(n = vcount(fauxNetwork), p.or.m = graph.density(fauxNetwork), directed = TRUE) trial[[i]] &lt;- triad.census(random_graph) # We assign to the ith space the result. So for the first iteration, it will assign the result to the first space in the list } Reduce(&quot;+&quot;,trial)/100 # The Reduce function will sum each element of the vectors in the list. We divide these values by 100 (the number of iterations) to get the average value for each type of triad for the 100 random graphs we generated ## [1] 1374447.25 39983.46 83.49 96.84 98.82 197.09 ## [7] 0.85 0.91 0.98 0.30 0.00 0.00 ## [13] 0.00 0.01 0.00 0.00 # Now we can compare this result to the observed network triad.census(fauxNetwork) ## [1] 1374298 40077 0 215 105 153 0 0 ## [9] 62 0 0 0 0 0 0 0 Beautiful! What do you see? Which triads are more common in our graph than in a random graph? What might this tell us about the macro-structure? "],
["centrality.html", "9 Centrality 9.1 Eigenvector Centrality", " 9 Centrality In this tutorial, we look at measures of network centrality, which we use to identify structurally important actors. We also discuss possible ideas for identifying important edges. Centrality originally referred to how central actors are in a network’s structure. It has become abstracted as a term from its topological origins and now refers very generally to how important actors are to a network. Topological centrality has a clear definition, but many operationalizations. Network “importance” on the other hand has many definitions and many operationalizations. We will explore the possible meanings and operationalizations of centrality here. There are four well-known centrality measures: degree, betweenness, closeness and eigenvector - each with its own strengths and weaknesses. The main point we want to make is that the analytical usefulness of each depends heavily on the context of the network, the type of relation being analyzed and the underlying network morphology. We don’t want to leave you with the impression that one is better than another - only that one might serve your research goals better than another. Every node-level measure has its graph-level analogue. Centralization measures the extent to which the ties of a given network are concentrated on a single actor or group of actors. We can also look at the degree distribution. It is a simple histogram of degree, which tells you whether the network is highly unequal or not. 9.0.1 Loading the example network As always, we need to load igraph. library(igraph) The dataset we are loading is called padgett_marriage.csv It is a subset of a famous dataset collected by John Padgett on the relationships of prominent Florentine families in 15th century Italy. The historical puzzle is that the Medici, an upstart family, seizes political power in 1434. Padgett’s goal was to explain how the Medici rose to power. He looked at many relations, but we only have the marriage here. Marriage was a tool in diplomacy, central to political alliances. A tie is drawn between families if the daughter of one family was sent to marry the son of another. Ron Breiger has argued these edges should be directed, tracing where daughters were sent, but we will analyze with the symmetrized (undirected) version. That is, we don’t differentiate between whether a son or daughter being sent from each family. As always, we first load and prepare the dataset. This time however we will load in the .csv files directly from the internet. We can put any direct web link to a .csv file in the read.csv function, and it will load the file. florentine_edgelist &lt;- read.csv(&quot;http://www.markanthonyhoffman.com/downloads/florentine_edgelist.csv&quot;, stringsAsFactors = FALSE, row.names = 1) florentine_attributes &lt;- read.csv(&quot;http://www.markanthonyhoffman.com/downloads/florentine_attributes.csv&quot;, stringsAsFactors = FALSE) marriageNet &lt;- graph_from_data_frame(d = florentine_edgelist, directed = F, vertices = florentine_attributes) marriageNet = simplify(marriageNet) Let’s see how it looks. plot(marriageNet, vertex.size = 2, vertex.label.cex = .4, vertex.label.color = &quot;black&quot;, vertex.color = &quot;tomato&quot;) Based on this plot, which family do you expect is most central? 9.0.2 Degree Centrality The simplest measure of centrality is degree centrality. It counts how many edges each node has - the most degree central actor is the one with the most ties. Note: In a directed network, you will need to specify if in or out ties should be counted. These will be referred to as in or out degree respectively. If both are counted, then it is just called degree Degree centrality is calculated using the degree function in R. It returns how many edges each node has. degree(marriageNet) ## Acciaiuoli Adimari Alberti Albizzi Aldobrandini ## 2 3 0 14 2 ## Alessandri Altoviti Dall&#39;Antella Ardinghelli Arnolfi ## 1 6 3 5 0 ## Arrighi Arrigucci Baldovinetti Barbadori Bardi ## 1 1 4 7 7 ## Baroncelli Baronci Bartoli Bartolini Belfradelli ## 1 1 1 1 1 ## Benci Bencivenni Del_Benino Benizzi Berlinghieri ## 0 1 1 1 0 ## Bischeri Brancacci Bucelli Del_Buletta Busini ## 4 2 2 0 0 ## Capponi Carducci Carnessecchi Della_Casa Castellani ## 4 2 0 2 7 ## Cavalcanti Cerretani Ciai Ciampegli Corbinelli ## 3 0 1 1 1 ## Corsi Davanzati Dietisalvi Doffi Donati ## 1 3 1 1 2 ## Fagni Federighi Fenci Fioravanti Del_Forese ## 0 1 0 2 0 ## Fortini Franceschi Frescobaldi Gianfigliazzi Ginori ## 0 0 6 10 4 ## Giugni Giuntini Guadagni Guasconi Guicciardini ## 3 0 10 12 7 ## Guiducci Lamberteschi Lapi Macinghi Mancini ## 0 1 1 1 1 ## Manelli Manovelli Martelli Masi Medici ## 2 2 2 1 20 ## Minerbetti Nasi(?) Nerli Orlandini Del_Palagio ## 1 1 1 2 2 ## Panciatichi Pandolfini Da_Panzano Parenti Pazzi ## 7 2 2 1 2 ## Pecori Pepi Peruzzi Pitti Popoleschi ## 1 1 15 2 2 ## Portinari Pucci Raugi Ricasoli Ricci ## 1 1 1 10 0 ## Ridolfi Rondinelli Rossi Rucellai Sacchetti ## 4 5 2 1 3 ## Salviati Scambrilla Dello_Scarfa Scolari Di_Ser_Segna ## 3 1 1 3 1 ## Serragli Serristori Soderini Solosmei Spini ## 2 1 1 1 4 ## Strozzi Della_Stufa Tanagli Tinucci Tornabuoni ## 25 0 2 0 4 ## Da_Uzzano Valori Vecchietti Velluti Da_Verrazzano ## 2 4 1 0 0 ## Vettori ## 1 Who is the most degree central? We can assign the output to a variable in the network and size the nodes according to degree. V(marriageNet)$degree &lt;- degree(marriageNet) # assignment plot(marriageNet, vertex.label.cex = .6, vertex.label.color = &quot;black&quot;, vertex.size = V(marriageNet)$degree) # sized by degree The problem is that the degree values are a little small to plot well. We can use a scalar to increase the value of the degree but maintain the ratio. plot(marriageNet, vertex.label.cex = .6, vertex.label.color = &quot;black&quot;, vertex.size = V(marriageNet)$degree*3) 9.0.3 Betweenness Centrality Betweenness centrality captures which nodes are important in the flow of the network. It makes use of the shortest paths in the network. A path is a series of adjacent nodes. For any two nodes we can find the shortest path between them, that is, the path with the least amount of total steps (or edges). If a node C is on a shortest path between A and B, then it means C is important to the efficient flow of goods between A and B. Without C, flows would have to take a longer route to get from A to B. Thus, betweenness effectively counts how many shortest paths each node is on. The higher a node’s betweenness, the more important they are for the efficient flow of goods in a network. In igraph, betweenness() computes betweenness in the network betweenness(marriageNet, directed = FALSE) ## Acciaiuoli Adimari Alberti Albizzi Aldobrandini ## 0.000000 93.009524 0.000000 856.436111 23.351190 ## Alessandri Altoviti Dall&#39;Antella Ardinghelli Arnolfi ## 0.000000 125.620147 174.000000 58.278211 0.000000 ## Arrighi Arrigucci Baldovinetti Barbadori Bardi ## 0.000000 0.000000 95.613889 162.697344 280.248232 ## Baroncelli Baronci Bartoli Bartolini Belfradelli ## 0.000000 0.000000 0.000000 0.000000 0.000000 ## Benci Bencivenni Del_Benino Benizzi Berlinghieri ## 0.000000 0.000000 0.000000 0.000000 0.000000 ## Bischeri Brancacci Bucelli Del_Buletta Busini ## 63.995238 0.000000 1.066667 0.000000 0.000000 ## Capponi Carducci Carnessecchi Della_Casa Castellani ## 177.000000 5.009524 0.000000 11.577398 194.199423 ## Cavalcanti Cerretani Ciai Ciampegli Corbinelli ## 125.467749 0.000000 0.000000 0.000000 0.000000 ## Corsi Davanzati Dietisalvi Doffi Donati ## 0.000000 260.000000 0.000000 0.000000 88.000000 ## Fagni Federighi Fenci Fioravanti Del_Forese ## 0.000000 0.000000 0.000000 5.951190 0.000000 ## Fortini Franceschi Frescobaldi Gianfigliazzi Ginori ## 0.000000 0.000000 145.532681 187.915043 180.571429 ## Giugni Giuntini Guadagni Guasconi Guicciardini ## 96.664141 0.000000 277.059921 583.679251 327.850305 ## Guiducci Lamberteschi Lapi Macinghi Mancini ## 0.000000 0.000000 0.000000 0.000000 0.000000 ## Manelli Manovelli Martelli Masi Medici ## 0.000000 88.000000 88.000000 0.000000 1029.609288 ## Minerbetti Nasi(?) Nerli Orlandini Del_Palagio ## 0.000000 0.000000 0.000000 88.000000 0.000000 ## Panciatichi Pandolfini Da_Panzano Parenti Pazzi ## 167.994891 0.000000 16.961111 0.000000 4.361111 ## Pecori Pepi Peruzzi Pitti Popoleschi ## 0.000000 0.000000 604.369691 19.610606 0.000000 ## Portinari Pucci Raugi Ricasoli Ricci ## 0.000000 0.000000 0.000000 205.097092 0.000000 ## Ridolfi Rondinelli Rossi Rucellai Sacchetti ## 213.727670 43.186597 0.000000 0.000000 197.651515 ## Salviati Scambrilla Dello_Scarfa Scolari Di_Ser_Segna ## 35.571429 0.000000 0.000000 19.801010 0.000000 ## Serragli Serristori Soderini Solosmei Spini ## 81.000000 0.000000 0.000000 0.000000 89.500000 ## Strozzi Della_Stufa Tanagli Tinucci Tornabuoni ## 1369.979110 0.000000 88.000000 0.000000 23.831746 ## Da_Uzzano Valori Vecchietti Velluti Da_Verrazzano ## 3.666667 202.285859 0.000000 0.000000 0.000000 ## Vettori ## 0.000000 We can again assign the output of betweenness() to a variable in the network and size the nodes according to it. V(marriageNet)$betweenness &lt;- betweenness(marriageNet) # assignment plot(marriageNet, vertex.label.cex = .6, vertex.label.color = &quot;black&quot;, vertex.size = V(marriageNet)$betweenness) # sized by betweenness Betweenness centrality can be very large. It is often helpful to normalize it by dividing by the maximum and multiplying by some scalar when plotting. plot(marriageNet, vertex.label.cex = .6, vertex.label.color = &quot;black&quot;, vertex.size = V(marriageNet)$betweenness/max(V(marriageNet)$betweenness) * 20) 9.0.4 Closeness Centrality With closeness centrality we again make use of the shortest paths between nodes. We measure the distance between two nodes as the length of the shortest path between them. Farness, for a given node, is the average distance from that node to all other nodes. Closeness is then the reciprocal of farness (1/farness). closeness(marriageNet) ## Acciaiuoli Adimari Alberti Albizzi Aldobrandini ## 3.036745e-04 3.052503e-04 7.496252e-05 3.095975e-04 3.044140e-04 ## Alessandri Altoviti Dall&#39;Antella Ardinghelli Arnolfi ## 2.918856e-04 3.065604e-04 3.035823e-04 3.075977e-04 7.496252e-05 ## Arrighi Arrigucci Baldovinetti Barbadori Bardi ## 2.990431e-04 2.972652e-04 3.060912e-04 3.068426e-04 3.088326e-04 ## Baroncelli Baronci Bartoli Bartolini Belfradelli ## 7.561437e-05 2.941176e-04 7.561437e-05 2.883506e-04 2.985966e-04 ## Benci Bencivenni Del_Benino Benizzi Berlinghieri ## 7.496252e-05 2.985075e-04 2.860412e-04 3.017502e-04 7.496252e-05 ## Bischeri Brancacci Bucelli Del_Buletta Busini ## 3.077870e-04 3.058104e-04 3.030303e-04 7.496252e-05 7.496252e-05 ## Capponi Carducci Carnessecchi Della_Casa Castellani ## 2.984184e-04 3.050641e-04 7.496252e-05 3.041363e-04 3.071253e-04 ## Cavalcanti Cerretani Ciai Ciampegli Corbinelli ## 3.073141e-04 7.496252e-05 2.958580e-04 2.980626e-04 3.023889e-04 ## Corsi Davanzati Dietisalvi Doffi Donati ## 3.013864e-04 3.019324e-04 2.958580e-04 2.990431e-04 2.934272e-04 ## Fagni Federighi Fenci Fioravanti Del_Forese ## 7.496252e-05 7.561437e-05 7.496252e-05 3.033981e-04 7.496252e-05 ## Fortini Franceschi Frescobaldi Gianfigliazzi Ginori ## 7.496252e-05 7.496252e-05 3.066544e-04 3.097893e-04 3.037667e-04 ## Giugni Giuntini Guadagni Guasconi Guicciardini ## 3.031222e-04 7.496252e-05 3.071253e-04 3.110420e-04 3.084516e-04 ## Guiducci Lamberteschi Lapi Macinghi Mancini ## 7.496252e-05 2.990431e-04 2.941176e-04 3.031222e-04 3.027551e-04 ## Manelli Manovelli Martelli Masi Medici ## 3.033060e-04 3.019324e-04 2.958580e-04 3.017502e-04 3.106555e-04 ## Minerbetti Nasi(?) Nerli Orlandini Del_Palagio ## 3.031222e-04 2.907822e-04 3.013864e-04 2.942908e-04 3.044140e-04 ## Panciatichi Pandolfini Da_Panzano Parenti Pazzi ## 3.090235e-04 2.964720e-04 3.013864e-04 3.031222e-04 3.010235e-04 ## Pecori Pepi Peruzzi Pitti Popoleschi ## 3.023889e-04 2.990431e-04 3.099814e-04 3.067485e-04 3.027551e-04 ## Portinari Pucci Raugi Ricasoli Ricci ## 3.023889e-04 2.868617e-04 7.561437e-05 3.072197e-04 7.496252e-05 ## Ridolfi Rondinelli Rossi Rucellai Sacchetti ## 3.075031e-04 3.067485e-04 3.023889e-04 3.031222e-04 3.042288e-04 ## Salviati Scambrilla Dello_Scarfa Scolari Di_Ser_Segna ## 3.036745e-04 2.962085e-04 7.561437e-05 3.044140e-04 3.027551e-04 ## Serragli Serristori Soderini Solosmei Spini ## 3.013864e-04 3.023889e-04 3.031222e-04 7.561437e-05 3.041363e-04 ## Strozzi Della_Stufa Tanagli Tinucci Tornabuoni ## 3.114295e-04 7.496252e-05 2.995806e-04 7.496252e-05 3.047851e-04 ## Da_Uzzano Valori Vecchietti Velluti Da_Verrazzano ## 3.037667e-04 3.010235e-04 3.023889e-04 7.496252e-05 7.496252e-05 ## Vettori ## 2.907822e-04 We assign it to a node variable and plot the network, adjusting node size by closeness. V(marriageNet)$closeness &lt;- closeness(marriageNet) plot(marriageNet, vertex.label.cex = .6, vertex.label.color = &quot;black&quot;, vertex.size = V(marriageNet)$closeness/max(V(marriageNet)$closeness) * 20) 9.1 Eigenvector Centrality Degree centrality only takes into account the number of edges for each node, but it leaves out information about ego’s alters. However, we might think that power comes from being tied to powerful people. If A and B have the same degree centrality, but A is tied to all high degree people and B is tied to all low degree people, then intuitively we want to see A with a higher score than B. Eigenvector centrality takes into account alters’ power. It is calculated a little bit differently in igraph. It produces a list object and we need to extract only the vector of centrality values. evcent(marriageNet)$vector ## Acciaiuoli Adimari Alberti Albizzi Aldobrandini ## 1.399699e-01 1.831812e-01 1.960911e-17 5.323660e-01 1.509870e-01 ## Alessandri Altoviti Dall&#39;Antella Ardinghelli Arnolfi ## 4.503879e-03 3.372469e-01 1.893404e-01 4.000982e-01 1.960911e-17 ## Arrighi Arrigucci Baldovinetti Barbadori Bardi ## 4.596917e-02 2.433106e-02 2.497482e-01 3.547849e-01 4.080706e-01 ## Baroncelli Baronci Bartoli Bartolini Belfradelli ## 7.001133e-18 1.421582e-02 9.930986e-18 3.400431e-03 4.564759e-02 ## Benci Bencivenni Del_Benino Benizzi Berlinghieri ## 1.960911e-17 4.479485e-02 1.231075e-03 1.051384e-01 1.960911e-17 ## Bischeri Brancacci Bucelli Del_Buletta Busini ## 3.348147e-01 2.232934e-01 1.218222e-01 1.960911e-17 1.960911e-17 ## Capponi Carducci Carnessecchi Della_Casa Castellani ## 2.844521e-02 1.799494e-01 1.960911e-17 1.414314e-01 4.238792e-01 ## Cavalcanti Cerretani Ciai Ciampegli Corbinelli ## 2.359640e-01 1.960911e-17 1.405106e-02 3.317283e-02 8.908790e-02 ## Corsi Davanzati Dietisalvi Doffi Donati ## 7.071156e-02 7.332195e-02 1.405106e-02 5.630179e-02 9.268390e-03 ## Fagni Federighi Fenci Fioravanti Del_Forese ## 1.960911e-17 1.693450e-17 1.960911e-17 1.350571e-01 1.960911e-17 ## Fortini Franceschi Frescobaldi Gianfigliazzi Ginori ## 1.960911e-17 1.960911e-17 3.436670e-01 7.162939e-01 1.057862e-01 ## Giugni Giuntini Guadagni Guasconi Guicciardini ## 1.011873e-01 1.960911e-17 3.460880e-01 6.811084e-01 3.830752e-01 ## Guiducci Lamberteschi Lapi Macinghi Mancini ## 1.960911e-17 4.596917e-02 9.738994e-03 1.328251e-01 9.046827e-02 ## Manelli Manovelli Martelli Masi Medici ## 1.659979e-01 1.070266e-01 2.560082e-02 1.051384e-01 6.707160e-01 ## Minerbetti Nasi(?) Nerli Orlandini Del_Palagio ## 1.328251e-01 3.778238e-03 7.071156e-02 9.913900e-03 1.383317e-01 ## Panciatichi Pandolfini Da_Panzano Parenti Pazzi ## 5.090917e-01 2.254509e-02 9.046017e-02 1.328251e-01 9.020762e-02 ## Pecori Pepi Peruzzi Pitti Popoleschi ## 8.908790e-02 5.630179e-02 7.915554e-01 2.219130e-01 1.134529e-01 ## Portinari Pucci Raugi Ricasoli Ricci ## 8.908790e-02 1.316815e-03 5.286142e-18 5.324287e-01 1.960911e-17 ## Ridolfi Rondinelli Rossi Rucellai Sacchetti ## 2.507818e-01 3.998861e-01 1.582815e-01 1.328251e-01 1.486187e-01 ## Salviati Scambrilla Dello_Scarfa Scolari Di_Ser_Segna ## 1.467173e-01 2.785107e-02 1.268825e-17 1.367356e-01 9.046827e-02 ## Serragli Serristori Soderini Solosmei Spini ## 5.798025e-02 8.908790e-02 1.328251e-01 4.065448e-18 2.096823e-01 ## Strozzi Della_Stufa Tanagli Tinucci Tornabuoni ## 1.000000e+00 1.960911e-17 3.390835e-02 1.960911e-17 1.834366e-01 ## Da_Uzzano Valori Vecchietti Velluti Da_Verrazzano ## 1.593404e-01 6.854784e-02 8.908790e-02 1.960911e-17 1.960911e-17 ## Vettori ## 3.778238e-03 Then we can assign that vector to our network and plot it. V(marriageNet)$eigenvector &lt;- evcent(marriageNet)$vector plot(marriageNet, vertex.label.cex = .6, vertex.label.color = &quot;black&quot;, vertex.size = V(marriageNet)$eigenvector/max(V(marriageNet)$eigenvector) * 20) 9.1.1 Measure Correlations Most of these measures are highly correlated, meaning they don’t necessarily capture unique aspects of pwoer. However, the amount of correlation depends on the network structure. Let’s see how the correlations between centrality measures looks in the Florentine Family network. cor.test(x,y) performs a simple correlation test between two vectors. cor.test(V(marriageNet)$degree, V(marriageNet)$betweenness) ## ## Pearson&#39;s product-moment correlation ## ## data: V(marriageNet)$degree and V(marriageNet)$betweenness ## t = 29.055, df = 114, p-value &lt; 2.2e-16 ## alternative hypothesis: true correlation is not equal to 0 ## 95 percent confidence interval: ## 0.9124632 0.9571526 ## sample estimates: ## cor ## 0.9386317 cor.test(V(marriageNet)$degree, V(marriageNet)$eigenvector) ## ## Pearson&#39;s product-moment correlation ## ## data: V(marriageNet)$degree and V(marriageNet)$eigenvector ## t = 25.9, df = 114, p-value &lt; 2.2e-16 ## alternative hypothesis: true correlation is not equal to 0 ## 95 percent confidence interval: ## 0.8926691 0.9471847 ## sample estimates: ## cor ## 0.9245214 cor.test(V(marriageNet)$degree, V(marriageNet)$closeness) ## ## Pearson&#39;s product-moment correlation ## ## data: V(marriageNet)$degree and V(marriageNet)$closeness ## t = 4.2754, df = 114, p-value = 3.981e-05 ## alternative hypothesis: true correlation is not equal to 0 ## 95 percent confidence interval: ## 0.2031884 0.5188843 ## sample estimates: ## cor ## 0.3717342 cor.test(V(marriageNet)$betweenness, V(marriageNet)$eigenvector) ## ## Pearson&#39;s product-moment correlation ## ## data: V(marriageNet)$betweenness and V(marriageNet)$eigenvector ## t = 13.93, df = 114, p-value &lt; 2.2e-16 ## alternative hypothesis: true correlation is not equal to 0 ## 95 percent confidence interval: ## 0.7147869 0.8526169 ## sample estimates: ## cor ## 0.7936739 cor.test(V(marriageNet)$betweenness, V(marriageNet)$closeness) ## ## Pearson&#39;s product-moment correlation ## ## data: V(marriageNet)$betweenness and V(marriageNet)$closeness ## t = 2.6627, df = 114, p-value = 0.008872 ## alternative hypothesis: true correlation is not equal to 0 ## 95 percent confidence interval: ## 0.06241416 0.40636643 ## sample estimates: ## cor ## 0.2419773 What do we learn? 9.1.2 Centralization and Degree Distributions To understand the measures further, we can look at their distributions. This will tell us roughly how many nodes have centralities of a given value. hist(V(marriageNet)$betweenness, xlab = &quot;Betweenness&quot;, main = &quot;Degree distribution of betweenness&quot;) We can see that most nodes in the marriage network have low betweenness centrality, and only one node has more than 40 betweenness. Degree distributions tend to be right-skewed; that is, only a few nodes in most networks have most of the ties. Evenly distributed degree is much rarer. Finally centralization measures the extent to which a network is centered around a single node. The closer a network gets to looking like a star, the more centralization will be. centralization.degree(marriageNet) ## $res ## [1] 2 3 0 14 2 1 6 3 5 0 1 1 4 7 7 1 1 1 1 1 0 1 1 ## [24] 1 0 4 2 2 0 0 4 2 0 2 7 3 0 1 1 1 1 3 1 1 2 0 ## [47] 1 0 2 0 0 0 6 10 4 3 0 10 12 7 0 1 1 1 1 2 2 2 1 ## [70] 20 1 1 1 2 2 7 2 2 1 2 1 1 15 2 2 1 1 1 10 0 4 5 ## [93] 2 1 3 3 1 1 3 1 2 1 1 1 4 25 0 2 0 4 2 4 1 0 0 ## [116] 1 ## ## $centralization ## [1] 0.1938531 ## ## $theoretical_max ## [1] 13340 centralization.betweenness(marriageNet) ## $res ## [1] 0.000000 93.009524 0.000000 856.436111 23.351190 ## [6] 0.000000 125.620147 174.000000 58.278211 0.000000 ## [11] 0.000000 0.000000 95.613889 162.697344 280.248232 ## [16] 0.000000 0.000000 0.000000 0.000000 0.000000 ## [21] 0.000000 0.000000 0.000000 0.000000 0.000000 ## [26] 63.995238 0.000000 1.066667 0.000000 0.000000 ## [31] 177.000000 5.009524 0.000000 11.577398 194.199423 ## [36] 125.467749 0.000000 0.000000 0.000000 0.000000 ## [41] 0.000000 260.000000 0.000000 0.000000 88.000000 ## [46] 0.000000 0.000000 0.000000 5.951190 0.000000 ## [51] 0.000000 0.000000 145.532681 187.915043 180.571429 ## [56] 96.664141 0.000000 277.059921 583.679251 327.850305 ## [61] 0.000000 0.000000 0.000000 0.000000 0.000000 ## [66] 0.000000 88.000000 88.000000 0.000000 1029.609288 ## [71] 0.000000 0.000000 0.000000 88.000000 0.000000 ## [76] 167.994891 0.000000 16.961111 0.000000 4.361111 ## [81] 0.000000 0.000000 604.369691 19.610606 0.000000 ## [86] 0.000000 0.000000 0.000000 205.097092 0.000000 ## [91] 213.727670 43.186597 0.000000 0.000000 197.651515 ## [96] 35.571429 0.000000 0.000000 19.801010 0.000000 ## [101] 81.000000 0.000000 0.000000 0.000000 89.500000 ## [106] 1369.979110 0.000000 88.000000 0.000000 23.831746 ## [111] 3.666667 202.285859 0.000000 0.000000 0.000000 ## [116] 0.000000 ## ## $centralization ## [1] 0.1985031 ## ## $theoretical_max ## [1] 753825 centralization.evcent(marriageNet) ## $vector ## [1] 0.139969900 0.183181185 0.000000000 0.532365989 0.150986997 ## [6] 0.004503879 0.337246899 0.189340415 0.400098205 0.000000000 ## [11] 0.045969167 0.024331056 0.249748224 0.354784865 0.408070618 ## [16] 0.000000000 0.014215821 0.000000000 0.003400431 0.045647594 ## [21] 0.000000000 0.044794847 0.001231075 0.105138414 0.000000000 ## [26] 0.334814659 0.223293355 0.121822157 0.000000000 0.000000000 ## [31] 0.028445212 0.179949410 0.000000000 0.141431437 0.423879187 ## [36] 0.235964042 0.000000000 0.014051056 0.033172828 0.089087904 ## [41] 0.070711556 0.073321953 0.014051056 0.056301788 0.009268390 ## [46] 0.000000000 0.000000000 0.000000000 0.135057071 0.000000000 ## [51] 0.000000000 0.000000000 0.343666976 0.716293858 0.105786164 ## [56] 0.101187330 0.000000000 0.346088004 0.681108355 0.383075212 ## [61] 0.000000000 0.045969167 0.009738994 0.132825082 0.090468273 ## [66] 0.165997910 0.107026632 0.025600819 0.105138414 0.670715974 ## [71] 0.132825082 0.003778238 0.070711556 0.009913900 0.138331700 ## [76] 0.509091680 0.022545088 0.090460172 0.132825082 0.090207623 ## [81] 0.089087904 0.056301788 0.791555424 0.221912986 0.113452883 ## [86] 0.089087904 0.001316815 0.000000000 0.532428666 0.000000000 ## [91] 0.250781843 0.399886089 0.158281491 0.132825082 0.148618699 ## [96] 0.146717333 0.027851072 0.000000000 0.136735584 0.090468273 ## [101] 0.057980251 0.089087904 0.132825082 0.000000000 0.209682322 ## [106] 1.000000000 0.000000000 0.033908347 0.000000000 0.183436579 ## [111] 0.159340427 0.068547839 0.089087904 0.000000000 0.000000000 ## [116] 0.003778238 ## ## $value ## [1] 7.528699 ## ## $options ## $options$bmat ## [1] &quot;I&quot; ## ## $options$n ## [1] 116 ## ## $options$which ## [1] &quot;LA&quot; ## ## $options$nev ## [1] 1 ## ## $options$tol ## [1] 0 ## ## $options$ncv ## [1] 0 ## ## $options$ldv ## [1] 0 ## ## $options$ishift ## [1] 1 ## ## $options$maxiter ## [1] 1000 ## ## $options$nb ## [1] 1 ## ## $options$mode ## [1] 1 ## ## $options$start ## [1] 1 ## ## $options$sigma ## [1] 0 ## ## $options$sigmai ## [1] 0 ## ## $options$info ## [1] 0 ## ## $options$iter ## [1] 2 ## ## $options$nconv ## [1] 1 ## ## $options$numop ## [1] 30 ## ## $options$numopb ## [1] 0 ## ## $options$numreo ## [1] 21 ## ## ## $centralization ## [1] 0.8766139 ## ## $theoretical_max ## [1] 114 centralization.closeness(marriageNet) ## $res ## [1] 0.034922563 0.035103785 0.008620690 0.035603715 0.035007610 ## [6] 0.033566842 0.035254445 0.034911961 0.035373731 0.008620690 ## [11] 0.034389952 0.034185493 0.035200490 0.035286898 0.035515750 ## [16] 0.008695652 0.033823529 0.008695652 0.033160323 0.034338609 ## [21] 0.008620690 0.034328358 0.032894737 0.034701267 0.008620690 ## [26] 0.035395506 0.035168196 0.034848485 0.008620690 0.008620690 ## [31] 0.034318114 0.035082367 0.008620690 0.034975669 0.035319410 ## [36] 0.035341119 0.008620690 0.034023669 0.034277198 0.034774720 ## [41] 0.034659433 0.034722222 0.034023669 0.034389952 0.033744131 ## [46] 0.008620690 0.008695652 0.008620690 0.034890777 0.008620690 ## [51] 0.008620690 0.008620690 0.035265256 0.035625774 0.034933171 ## [56] 0.034859048 0.008620690 0.035319410 0.035769829 0.035471931 ## [61] 0.008620690 0.034389952 0.033823529 0.034859048 0.034816833 ## [66] 0.034880194 0.034722222 0.034023669 0.034701267 0.035725381 ## [71] 0.034859048 0.033439953 0.034659433 0.033843437 0.035007610 ## [76] 0.035537701 0.034094278 0.034659433 0.034859048 0.034617700 ## [81] 0.034774720 0.034389952 0.035647861 0.035276074 0.034816833 ## [86] 0.034774720 0.032989099 0.008695652 0.035330261 0.008620690 ## [91] 0.035362854 0.035276074 0.034774720 0.034859048 0.034986310 ## [96] 0.034922563 0.034063981 0.008695652 0.035007610 0.034816833 ## [101] 0.034659433 0.034774720 0.034859048 0.008695652 0.034975669 ## [106] 0.035814388 0.008620690 0.034451768 0.008620690 0.035050290 ## [111] 0.034933171 0.034617700 0.034774720 0.008620690 0.008620690 ## [116] 0.033439953 ## ## $centralization ## [1] 0.01402947 ## ## $theoretical_max ## [1] 57.24891 "],
["the-small-world-problem-and-the-art-science-of-simulation.html", "10 The Small World Problem and the Art-Science of Simulation", " 10 The Small World Problem and the Art-Science of Simulation Real-world social networks tend to be small worlds. In a small world, people are clustered in groups, but despite this, are still, on average, socially proximate. For example, you might think that you are socially (and spatially) distant from a random villager in India, but find that through a series of steps, you could reach that villager. The villager lives in her own small world and you live in yours, and yet you are mutually reachable. This is referred to as “the Small-World Phenomenon”. Duncan Watts in his landmark paper explains this phenomenon. He begins with most clustered (and yet connected graph) imaginable - a “caveman” structure. There are groups of people clustered together and connected by only one or two connections to other groups. Sadly, igraph doesn’t have a function for simulating caveman structures, so I quickly wrote one myself. In this caveman structure, all of the groups will be the same size, so the number of people must be evenly divisible by the size of groups. The basic idea is to generate a bunch of fully connected groups and then connect them by an edge or two so that they are arrayed around a circle. simulate_caveman &lt;- function(n = 25, clique_size = 5){ require(igraph) # Groups are all the same size, so I check whether N is divisible by the size of groups if ( ((n%/%clique_size) * clique_size) != n){ stop(&quot;n is not evenly divisible by clique_size&quot;) } groups = n/clique_size # this determines the number of groups el &lt;- data.frame(PersonA = 1:n, Group = NA) # I create a dataframe which has people and the groups they are in # I treat it like a person to group edgelist group_vector = c() for (i in 1:groups){ group_vector &lt;- c(group_vector, rep(i, clique_size)) } el$Group &lt;- group_vector inc &lt;- table(el) # I use the table function to turn the person to group edgelist into an incidence matrix adj &lt;- inc %*% t(inc) # And I use matrix multiplication with the transpose to turn the person to group incidence matrix # into a person to person adjacency matrix diag(adj) &lt;- 0 g &lt;- graph.adjacency(adj, mode = &quot;undirected&quot;) # I graph this matrix group_connect &lt;- seq(from = 1, to = n, by = clique_size) # I determine the points of connection using a sequence funciton for( i in 1:(length(group_connect)-1)){ p1 &lt;- group_connect[i] + 1 p2 &lt;- group_connect[i+1] g &lt;- add.edges(g, c(p1,p2)) # And I connect the points of connection using add.edges } g &lt;- add.edges(g, c(group_connect[1],(group_connect[groups]+1))) # finally I connect the ends of the structure so that it forms a circle return(g) } You don’t have to understand every part of this function in order to use it. All you need to do is run the function above so that it is in your R environment. You can then use it. It has two arguments - number of nodes and the size of the groups. You could change clique_size to 4 or 10. caveman_net &lt;- simulate_caveman(n = 100, clique_size = 5) par(mar = c(2,2,2,2)) plot(caveman_net, layout = layout.kamada.kawai(caveman_net), vertex.size = 2, vertex.label = NA, vertex.color = &quot;grey80&quot;) Now you can clearly see what a caveman structure is. Let’s analyze it. graph.density(caveman_net) ## [1] 0.04444444 transitivity(caveman_net) # transitivity() measures clustering coefficient, which essentially says, how clustered is the network overall ## [1] 0.7894737 average.path.length(caveman_net) ## [1] 10.70101 It has a pretty low density since most nodes only have connections within their clique or else one tie outwards. And as I mentioned above, caveman structures are extremely clustered, since most edges are within group. Path length is also high - basically it takes 10 steps, on average, to reach one node from a random other node. In the real world, there are way more than 100 people and more than 20 groups, so it should be even more surprising that the average degree of separation is roughly six or seven steps. It follows that the “caveman structure” is not a small-world. We can look at the diameter of the network to see this too. The diameter is the longest shortest path. nodes.diameter&lt;-get.diameter(caveman_net) V(caveman_net)[nodes.diameter]$color&lt;-&quot;darkgreen&quot; # This assigns those nodes the color darkgreen. plot(caveman_net, layout = layout.kamada.kawai(caveman_net), vertex.size = 2, vertex.label = NA) Let’s reset color. V(caveman_net)$color &lt;- &quot;orange&quot; Watts wants to get from this network structure, to one in which the average path length is much lower. He performs a simple exercise to do so (and one we have already experimented with). He randomly rewires the network so that it begins, slowly to approximate a random graph. Random graphs have low average path length; so this is a good idea. We end up with a caveman structure with some number of rewired edges that will have the tendency to cut across the network caveman_net_rewired &lt;- caveman_net %&gt;% rewire(keeping_degseq(niter = 1000)) We can use the rewire function to rewire the network. keeping_degseq() ensures that the degree distribution does not change and niter = 20 is the number of iterations (rewirings). plot(caveman_net_rewired, layout = layout.kamada.kawai(caveman_net), vertex.size = 2, vertex.label=NA) Most of the rewirings cut across the network structure! plot(caveman_net_rewired, layout = layout.kamada.kawai(caveman_net_rewired), vertex.size = 2, vertex.label=NA) # Here it is laid out properly plot(caveman_net_rewired, layout = layout.kamada.kawai(caveman_net_rewired), vertex.size = 2, vertex.label = NA, vertex.color = &quot;grey80&quot;) Let’s compare this to the caveman network. graph.density(caveman_net_rewired) ## [1] 0.04444444 transitivity(caveman_net_rewired) ## [1] 0.03157895 average.path.length(caveman_net_rewired) ## [1] 3.301818 Density is unchanged. Clustering coefficient is less than before, but still relatively high. And average.path.length was cut in half. Only 20 rewirings and look at the change! We can analyze the change as we perform more rewirings. avgpathlength &lt;- average.path.length(caveman_net) # These are the first observation clusteringcoefficient &lt;- transitivity(caveman_net) caveman_net_rewired &lt;- caveman_net iter = 100 for ( i in 2:iter){ caveman_net_rewired &lt;- caveman_net_rewired %&gt;% rewire(keeping_degseq(niter = 1)) avgpathlength &lt;- c(avgpathlength, average.path.length(caveman_net_rewired)) # We are just appending the result to a vector clusteringcoefficient &lt;- c(clusteringcoefficient, transitivity(caveman_net_rewired)) } plot(1:100, avgpathlength, xlab = &quot;Numer of Rewirings&quot;, ylab = &quot;Average Path Length&quot;, main = &quot;Caveman&quot;, type = &quot;l&quot;) plot(1:100, clusteringcoefficient, xlab = &quot;Numer of Rewirings&quot;, ylab = &quot;Clustering Coefficient&quot;, main = &quot;Caveman&quot;, type = &quot;l&quot;) 10.0.1 Other simulations Simulations are used a lot in networks. We only talk in class about random nets and small-worlds, but there are many ideal-type networks. The third most famous is the “scale-free” network. “scale-free networks” are also known as hub-based networks, because they have a few actors with high degree and many actors with low degree. They are therefore highly centralized, and generally have low clustering. igraph has a built in function to generate this class of networks: barabasi.game() scalefree &lt;- barabasi.game(n=100, m=5) plot(scalefree, vertex.size = 3, layout = layout.kamada.kawai(scalefree), edge.arrow.size = .1, vertex.label=NA) graph.density(scalefree) ## [1] 0.0489899 transitivity(scalefree) ## [1] 0.1878177 average.path.length(scalefree) ## [1] 1.618956 Density, when m = 5, is roughly the same as the small-world network. Clustering coefficient is much lower. And average path length is short, because people can access almost everyone else via the hubs in the network. Look for other games in the igraph manual… or, you can write your own like we did above. "]
]
