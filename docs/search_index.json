[
["index.html", "Social Network Analysis Welcome", " Social Network Analysis Peter Bearman and Mark Hoffman Welcome Peter Bearman psb17@columbia.edu Mark Hoffman Mh3279@columbia.edu This seminar is intended as a theoretical and methodological introduction to social network analysis. Though network analysis is an interdisciplinary endeavor, its roots can be found in classical anthropology and sociology. Network analysis focuses on patterns of relations between actors. Both relations and actors can be defined in many ways, depending on the substantive area of inquiry. For example, network analysis has been used to study the structure of affective links between persons, flows of commodities between organizations, shared members between social movement organizations, and shared needles between drug users. What is central is an emphasis on the structure of relationality, which serves to link micro- and macro-level processes. We will spend this course becoming familiar with the theoretical foundations of structural network analysis, including principles of balance and transitivity, the implications of connectivity and density, the relationship between categories and networks, the nature of exchange structures, and power and centrality. We will also discuss substantive applications of the network approach. Each class covers substantive and theoretical material and is associated with a technical lab. You will need to bring your laptops to each class. In the technical labs you will learn how to analyze network data in R. This e-book contains all of the technical labs, in the order that we will cover them. Should you forget anything we learned, you will be to return to this book and go through the tutorial again. In addition, at the end of each chapter is a list of readings, which pertain to the theoretical and methodological topics discussed in each class. We start with the basics: installing R and R Studio, creating and loading network data structures into R and plotting networks and network aesthetics. We then analyze networks using descriptive statistics, including size, density, reciprocity, transitivity, centrality, assortativity and modularity. Next we discuss bipartite graphs and their analysis. We conclude with network simulation and modeling. "],
["installing-r-and-rstudio.html", "1 Installing R and RStudio 1.1 Downloading and Installing R 1.2 Downloading and Installing RStudio", " 1 Installing R and RStudio In this section, we will learn how to install R and RStudio. Both are freely available online. 1.1 Downloading and Installing R Description R is an open source programming language designed for statistical computing and visualization. Scientists and data analysts worldwide use it for purposes ranging from regression analysis, to natural language processing, to biological simulation, to social network analysis - the topic of this class. Being open source, users from around the world add new functions to its repositories on a daily basis. This means that the possible tools you can use and analyses you can perform with R are expanding constantly, making it an increasingly powerful environment for statistical analysis. We will show you just a glimpse of this power, but hopefully we can provide enough of a basis for you to go out on your own and learn more. Steps Navigate to https://www.r-project.org/ Click on the blue, bolded “download R” in the first paragraph. Choose a mirror (in other words, a website hosting current and past R distributions) located somewhere near to you. I am based in New York so I chose one based out of Carnegie Mellon in Pennsylvania. Download R by clicking on one of the “Download R for” links. Choose the link that accords with your operating system. I am using Mac, so I clicked: “Download R for (Mac) OS X” Next click the first link underneath the “Files” heading. This should begin the download. Follow the instructions on the installer that begins when you click on the downloaded file. Once you are finished, R should be installed on your system. 1.2 Downloading and Installing RStudio Description Next we need to install RStudio. RStudio is a user interface for R, which greatly improves the experience of working in R. As stated on its website, some of its features include: Customizable workbench with all of the tools required to work with R in one place (console, source, plots, workspace, help, history, etc.). Syntax highlighting editor with code completion. Execute code directly from the source editor (line, selection, or file). Full support for authoring Sweave and TeX documents. Runs on all major platforms (Windows, Mac, and Linux) and can also be run as a server, enabling multiple users to access the RStudio IDE using a web browser. Steps To download RStudio, navigate to https://www.rstudio.com/ and click the download RStudio button: Scroll down and click on the green “Download” button in the RStudio Desktop column. RStudio is free! This should cause your browser to scroll down to the bottom of the page where you will see a series of blue installers. Click the installer (not Zip/Tarball!) according to your operating system. This should prompt a download. Double click on the downloaded file, which will begin the installation process. If you are on Mac OS X, drag RStudio to your Applications folder. Now you are all set to go for the tutorial! Find RStudio wherever you saved it (Applications folder if you are on Mac), and open it. In the next chapter, we will learn what to do once it is up and running. "],
["tour-rstudio-with-udacity.html", "2 Tour RStudio with Udacity", " 2 Tour RStudio with Udacity Now that RStudio is open watch the Udacity video below to learn more about the interace and how to use it. Once you finish, we will begin programming in R. "],
["r-basics.html", "3 R Basics 3.1 Vectors, matrices and dataframes 3.2 Indexing and Subsetting 3.3 Loading Packages", " 3 R Basics This initial tutorial for R has two primary learning objectives. The first is to become affiliated with the R environment and the second is to learn how to extend the basic set of R functions to make it suitable for your own research purposes. The lessons we learn in this tutorial will serve as a strong basis for the those that follow, which focus on the actual analysis of networks using R. Like most programming languages, R can serve as a calculator. We will use many of these basic mathematical operations when working with network data. 2+2 ## [1] 4 ((2+2)*3)/6 ## [1] 2 2^2 ## [1] 4 We use the assignment operator “&lt;-” to save the results in a vector for later. four &lt;- 2+2 sixteen &lt;- (2+2)^2 If we type the name of the vector, it will return its values. four ## [1] 4 sixteen ## [1] 16 Functions in R also have names. Later on, we will learn to write our own functions. For now, we can make use of the large body of default functions that exist within R. The most basic function is print. We can use it to output text in the console. print(&quot;Hello world!&quot;) ## [1] &quot;Hello world!&quot; log() is another useful function and it has two arguments, x and base. When you call the function log() you have to specify x (the input value), while base has a default of exp(1). log82 &lt;- log(x = 8, base = 2) If you don’t specify the arguments in their correct order, you must use argument=value form or else you will get a different result. log1 &lt;- log(8, base = 2) log2 &lt;- log(x = 8, base = 2) log3 &lt;- log(8, 2) log4 &lt;- log(base = 2, x = 8) log5 &lt;- log(2, 8) The cat function concatenates the R objects and prints them. cat(log1, log2, log3, log4, log5) ## 3 3 3 3 0.3333333 As you can see, the fifth specification of the logarithm returned different results. 3.1 Vectors, matrices and dataframes Vectors are the most basic object in R. They contain ordered elements of the same type. Vectors of size &gt; 1 are created using the “c” function. v &lt;- c(0,1,2,3,4,5,6,7,8,9) print(v) ## [1] 0 1 2 3 4 5 6 7 8 9 Computations on vectors are performed element-wise. v &lt;- v * 3 print(v) ## [1] 0 3 6 9 12 15 18 21 24 27 Matrices can be created using the matrix function. I specify what I want in each cell of the matrix and the dimensions of the matrix. This will make a square 5 by 5 matrix with all zeroes. If the argument “byrow” is TRUE, the matrix will be filled row by row (horizontally). Otherwise, it will be filled by column (vertically). zero &lt;- rep(0,5) # the rep function replicates the values in x a given number of times one &lt;- rep(1,5) matrix_data &lt;- matrix(c(zero,one,zero,one,zero), nrow = 5, ncol = 5, byrow = TRUE) matrix_data ## [,1] [,2] [,3] [,4] [,5] ## [1,] 0 0 0 0 0 ## [2,] 1 1 1 1 1 ## [3,] 0 0 0 0 0 ## [4,] 1 1 1 1 1 ## [5,] 0 0 0 0 0 matrix_data &lt;- matrix(c(zero,one,zero,one,zero), nrow = 5, ncol = 5, byrow = FALSE) matrix_data ## [,1] [,2] [,3] [,4] [,5] ## [1,] 0 1 0 1 0 ## [2,] 0 1 0 1 0 ## [3,] 0 1 0 1 0 ## [4,] 0 1 0 1 0 ## [5,] 0 1 0 1 0 Using the sample function, we can fill each cell randomly with either 0 or 1. This simulates an adjancency matrix for a network where connections between people are random. matrix_data2 &lt;- matrix(sample(c(1,0), 25, replace = TRUE, prob=c(.5,.5)), nrow=5, ncol=5, byrow =TRUE) matrix_data2 ## [,1] [,2] [,3] [,4] [,5] ## [1,] 0 0 0 0 1 ## [2,] 1 0 1 0 0 ## [3,] 0 0 1 0 0 ## [4,] 0 0 1 1 1 ## [5,] 1 0 0 1 1 Finally, using dimnames, we can name each dimension, which makes sense given we are working with “social” networks. matrix_data3 &lt;- matrix(sample(c(1,0), 25, replace = TRUE, prob=c(.5,.5)), nrow=5, ncol=5, byrow =TRUE, dimnames = list(c(&quot;Thea&quot;, &quot;Pravin&quot;, &quot;Troy&quot;, &quot;Albin&quot;, &quot;Clementine&quot;), c(&quot;Thea&quot;, &quot;Pravin&quot;, &quot;Troy&quot;, &quot;Albin&quot;, &quot;Clementine&quot;))) matrix_data3 ## Thea Pravin Troy Albin Clementine ## Thea 1 1 1 1 0 ## Pravin 0 0 0 0 0 ## Troy 0 1 1 1 0 ## Albin 0 1 1 0 0 ## Clementine 0 1 1 1 1 We can convert a matrix into a data.frame and vice versa. The class() function tells us what type of object we are working with. matrix_data3 &lt;- as.matrix(matrix_data3) class(matrix_data3) ## [1] &quot;matrix&quot; matrix_data3 &lt;- as.data.frame(matrix_data3) class(matrix_data3) ## [1] &quot;data.frame&quot; Data frames behave like a Stata dataset, for those that are familiar. However, they are inefficient in R and are increasingly being replaced by user-created data classes, such as data.table. In this class, we will deal primarily with matrices, but if you use regression analysis it will be worth your time to explore data.frames. 3.2 Indexing and Subsetting When we are working with a matrix or data.frame, we might want to access or manipulate a single row or column at a time. To do so, we need to index a row or column. This can be done in two ways. If we are working with a data.frame, we can use the $ operator. The name of the column we wish to access follows the dollar sign. matrix_data3$Thea will return the column values for Thea. matrix_data3 ## Thea Pravin Troy Albin Clementine ## Thea 1 1 1 1 0 ## Pravin 0 0 0 0 0 ## Troy 0 1 1 1 0 ## Albin 0 1 1 0 0 ## Clementine 0 1 1 1 1 matrix_data3$Thea ## [1] 1 0 0 0 0 We can then manipulate the column directly matrix_data3$Thea &lt;- 1 matrix_data3 ## Thea Pravin Troy Albin Clementine ## Thea 1 1 1 1 0 ## Pravin 1 0 0 0 0 ## Troy 1 1 1 1 0 ## Albin 1 1 1 0 0 ## Clementine 1 1 1 1 1 We can also use subscripting. For example, matrix_data3[,1] tells R to return the first column while matrix_data3[1,] tells R to return the first row. Finally, matrix_data3[1,1] is the cell located in the first row of the first column. This is more flexible than $, but requires you to know the locations of the intended data in the dataset or matrix. matrix_data3[,1] ## [1] 1 1 1 1 1 matrix_data3[1,] ## Thea Pravin Troy Albin Clementine ## Thea 1 1 1 1 0 matrix_data3[1,1] ## [1] 1 Vectors are also indexed, but they only have one dimension, so no comma is needed. trial_vector &lt;- c(1,2,3,4,5,6) trial_vector[1] ## [1] 1 Finally, we may wish to remove columns in a data.frame, matrix or vector. We can use the subset function to do this. trial_vector &lt;- subset( trial_vector, trial_vector &gt; 2) trial_vector ## [1] 3 4 5 6 We can perform this same operation with subscripts trial_vector &lt;- c(1,2,3,4,5,6) trial_vector &lt;- trial_vector[trial_vector &gt; 2] In effect, they both say - take a subset of trial_vector in which the value in the vector is greater than 2 Finally we can use the subscript index method to change values if they meet a certain criteria trial_vector &lt;- c(1,2,3,4,5,6) trial_vector[trial_vector &gt; 2] &lt;- 10 trial_vector ## [1] 1 2 10 10 10 10 We won’t use subset with matrices, but we will likely index them. Subsetting is more commonly used with data.frames 3.3 Loading Packages Packages are collections of R functions, data, and compiled code. They are built by members of the R community to add functionality to base R. Generally, if you wish you could do something with R, someone has built a package to do it already! We will use a few packages, some of which are built into R. We will need to install the others. For now, we just need to install igraph, which is the most developed network analysis package for R. To do so, we use the install.packages() function. # install.packages(&quot;igraph&quot;) The library function tells R to add the package to the current R session library(igraph) ## ## Attaching package: &#39;igraph&#39; ## The following objects are masked from &#39;package:stats&#39;: ## ## decompose, spectrum ## The following object is masked from &#39;package:base&#39;: ## ## union We will use the library() function every time we start a new R session. If R cannot find a function that you are sure is in a package you use, it normally means the package isn’t loaded or that you somehow misspelled the function name. "],
["understanding-network-data-structures.html", "4 Understanding network data structures 4.1 Edge lists 4.2 Adjacency matrices", " 4 Understanding network data structures Underlying every network visualization is data about relationships. These relationships can be observed or simulated (that is, hypothetical). When analyzing a set of relationships, we will generally use one of two different data structures: edge lists or adjacency matrices. 4.1 Edge lists One simple way to represent a graph is to list the edges, which we will refer to as an edge list. For each edge, we just list who that edge is incident on. Edge lists are therefore two column matrices that directly tell the computer which actors are tied for each edge. In a directed graph, the actors in column A are the sources of edges, and the actors in Column B recieve the tie. In an undirected graph, order doesn’t matter. In R, we can create an example edge list using vectors and data.frames. I specify each column of the edge list with vectors and then assign them as the columns of a data.frame. We can use this to visualize what an edge list should look like. personA &lt;- c(&quot;Mark&quot;, &quot;Mark&quot;, &quot;Peter&quot;, &quot;Peter&quot;, &quot;Bob&quot;, &quot;Jill&quot;) personB &lt;- c(&quot;Peter&quot;, &quot;Jill&quot;, &quot;Bob&quot;, &quot;Aaron&quot;, &quot;Jill&quot;, &quot;Aaron&quot;) edgelist &lt;- data.frame(PersonA = personA, PersonB = personB, stringsAsFactors = F) print(edgelist) ## PersonA PersonB ## 1 Mark Peter ## 2 Mark Jill ## 3 Peter Bob ## 4 Peter Aaron ## 5 Bob Jill ## 6 Jill Aaron What are the upsides of using the edge list format? As you can see, in an edge list, the number of rows accords to the number of edges in the network since each row details the actors in a specific tie. It is therefore really simple format for recording network data in an excel file or csv file. What are the downsides? The first is practical - it is impossible to represent isolates using an edge list since it details relations. There are ways to get around this problem in R, however. The second is technical - edge lists are not suitable for data formats for performing linear algebraic techniques. As a result, we will almost always convert and edge list into either an adjacency matrix, or into a network object. 4.2 Adjacency matrices Adjacency matrices have one row and one column for each actor in the network. The elements of the matrix can be any number but in most networks, will be either 0 or 1. A matrix element of 1 (or greater) signals that the respective column actor and row actor should be tied in the network. Zero signals that they are not tied. We can use what we learned in the last tutorial to create such a matrix. An example might look like this: adjacency &lt;- matrix(c(0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0), nrow = 5, ncol = 5, dimnames = list(c(&quot;Mark&quot;, &quot;Peter&quot;, &quot;Bob&quot;, &quot;Jill&quot;, &quot;Aaron&quot;), c(&quot;Mark&quot;, &quot;Peter&quot;, &quot;Bob&quot;, &quot;Jill&quot;, &quot;Aaron&quot;))) print(adjacency) ## Mark Peter Bob Jill Aaron ## Mark 0 1 0 1 0 ## Peter 1 0 1 0 1 ## Bob 0 1 0 1 0 ## Jill 1 0 1 0 1 ## Aaron 0 1 0 1 0 What are the upsides of using the adjacency matrix format? Adjacency matrices are the most fundamental network analysis data format. They undergird all of the analytical techniques we will show you later on. They are also much more efficient than edge lists. For example, imagine searching for whether Peter and Jill are friends in an adjacency matrix as opposed to an edge list. In the adjacency matrix, we would go to Peter’s row and Jill’s column and we would find either a 1 or a 0, giving us our answer. In an edge list, we would have to search through each edge, which might seem simple in a dataset with only 5 people, but as the edge list grows, it will scale linearly with the number of edges. What are the downsides? It is really difficult to record network data with an adjacency matrix. They are better suited for computers than people. "],
["your-first-network.html", "5 Your First Network 5.1 Creating a project 5.2 Creating data in Excel 5.3 Saving Excel data as a .csv file 5.4 Loading data into R 5.5 From data to networks 5.6 Our first network", " 5 Your First Network In this chapter, we will create our own network data in Excel, learn to load the data into R, and the turn the data into a network object using the igraph package. You can use these steps to begin analyzing data from your own projects. 5.1 Creating a project First let’s create a new R project. RStudio projects allow you to keep your various data analysis projects separate from one another. Each project has its own working directory, workspace, history, and source documents. When you load a project, you will therefore see the work, history and files associated with that project, helping your organize your work. Go to the “File” menu at the top of the screen and click on “New Project…” Then start a new directory. Directories are folders where you keep your R Project and all of the data, files, code etc. that you create and use in the project. Now start an empty project. Projects are created by RStudio and they maintain your R workspace for you, so that you can load it exactly as it was before you closed RStudio. Finally name your project (I named mine “SNA_Tutorial”) and browse to find the location on your computer where you would like it to be saved. We will use this directory to store all of the files and information for the class, so make sure to choose a name you can remember. Now if you navigate to the folder of your new R Project (mine is on my Desktop in the folder titled “SNA Tutorial”, for example), you will see the R Project there, symbolized by a blue glass cube with an R in it. If you ever want to re-open this project, you can double click on the cube. Alternatively, in RStudio you can go “File -&gt; Open Project”, navigate to the project’s directory and open it from there. This folder is where you should keep all of your data and R scripts for this project. Since we just created the project that we will use for the remainder of the tutorials, it is the best place for you to put all future class materials. 5.2 Creating data in Excel Imagine you want to collect some data on your local social network. You might go to each of your friends and ask them to nominate up to five people who are their friends. You then want to load this data into R and graph it as a network. How could you go about doing this? The first step is to record the data in some machine-readable way, either using Excel or Numbers or even in plain text files. Many people, before coming to R, have experience using Excel or some program like it to manage data, whether financial, academic, or otherwise. An Excel worksheet is organized into rows and columns with columns generally containing information of a single kind (say First Names) and rows generally containing the data for a single observation. You can freely input data into any of the cells. An empty Excel spreadsheet The first step in any network analysis project is to create a dataset with the relationships between the people in your study. The easiest way to record relationships in Excel is as an edgelist, which, as we discussed in the last section, is a two column matrix that lists the pairs of actors in a relationship. Let’s build an edgelist together in Excel. Imagine we want to track patterns of monetary gift giving in a household (i.e. whether person A gives person B money). We construct an egelist, where column A is the Ego (the gift giver) and column B is the Alter (the gift receiver). We then fill in instances, or relationships, of gift giving from Ego to Alter. Below is an example: Gift giving edgelist (Hoffman family) Try recording something similar for your family! 5.3 Saving Excel data as a .csv file Great! Now we need to save this data in a format that R can easily read. I generally use the .csv format, which separates values by commas, because R has a default function for reading .csv files. To save an Excel sheet as a .csv file, in Excel go to “File -&gt; Save As…” Then give your file a name (I chose “money_edgelist”), choose the place where you want to save it (inside of the directory you made for class), and finally (the most important part!), click on the “File Format” dropdown menu and choose “Comma Separated Values (.csv)”. Click “Save”! It will ask will warn you that the workbook contains features that will not work or may be removed if you save it in the selected file format and ask if you want to continue. Click “Continue”. Great! Now, inside of your class directory, you should see a new file titled “money_edgelist” (or whatever you chose to name it). In the following section, we will learn how to read that edgelist into R. 5.4 Loading data into R Open up RStudio, make sure you are in your project for class (if not, go to “File -&gt; Open Project”, and selection your project), and open a new R Script by going “File -&gt; New File -&gt; R Script”. Save the empty script and name it “loading_data.R”. Your RStudio should look like this: Now we will write our first line of code together. R has a simple function for loading .csv files: read.csv() To use read.csv, we just tell R the name of the .csv file that we want it to read. It will then look inside the directory for that file. If it can’t find the file - either because you typed the wrong name or you never dragged it to the directory - it will return the following error: Error in file(file, “rt”) : cannot open the connection In addition: Warning message: In file(file, “rt”) : cannot open file ‘money_edgelista.csv’: No such file or directory So sure money_edgelist.csv is in your directory or else the following lines of code won’t work! money_edgelist = read.csv(&quot;money_edgelist.csv&quot;) Now you should see in your Environment pane “money_edgelist” under the “Data” heading. That means you successfully loaded the data into R. You can click on it to see its contents or else run View(money_edgelist) in the console. Cool! We now have our data loaded into R, ready to be turned into a network. 5.5 From data to networks In this class, we will primarily use igraph, a user-maintained package in R, to analyze networks. Installing igraph gives us a bunch of new tools for graphing, analyzing and manipulating networks, that don’t come with base R. The first step then is to install igraph. To install a new package, we use the install.packages() function. It takes a character argument that is the name of the package you wish to install. install.packages(&quot;igraph&quot;, repos=&#39;http://cran.us.r-project.org&#39;) ## ## The downloaded binary packages are in ## /var/folders/k0/_v5yt5b901v5vtff0y7zmgmr0000gn/T//RtmpmQ05m4/downloaded_packages If you leave out the “repos” argument, it will cause a window to pop up with a list of CRAN mirrors. Then you can choose the repository nearest to you by double clicking on it. Now that igraph is installed, we need to use the library() function to load it into R. You will have to do this everytime you open RStudio or switch projects if you wish to make use of igraph’s functions. library(&quot;igraph&quot;) Great! Now we can use all of igraph’s functions. To analyze networks, igraph uses an object class called: “igraph”. We therefore have to convert our edge list, freshly loaded into R, into an igraph object. igraph only takes matrices, so we then have to convert our data.frame (the default class of objects returned by read.csv()) to a matrix. money_edgelist &lt;- as.matrix(money_edgelist) We can now turn the money_edgelist edge list into a network object. The required function is graph.edgelist() and it takes two arguments, the network data (an edge list) and whether the edges are directed or undirected. In this case, because giving money is not necessarily a reciprocal relationship (i.e. just because I give you money, doesn’t mean you necessarily give it back… in fact, the opposite is almost always the case!), the network should be directed. moneyNetwork &lt;- graph.edgelist(money_edgelist, directed=TRUE) A Note on Function Documentation If you want to see more about graph.edgelist() or if you want to see other ways to graph data type, you can type ?graph.edgelist. Entering ? before any function will cause R to bring up documentation on that function. Now we have two objects in our Environment, the money_edgelist and a new networked, called moneyNetwork. Both contain the same information at the moment, but igraph can only make use of the latter. What if my data was in adjacency matrix format? If your data was in adjacency matrix format, then you would use the graph.adjacency() function instead of the graph.edgelist() function. More about the graph.adjacency() function can be read in the function’s help section accessed by typing ?graph.adjacency 5.6 Our first network We finally have a network in R! So.. what next? Well we can read a summary of it by typing its name into R. moneyNetwork ## IGRAPH DN-- 6 11 -- ## + attr: name (v/c) ## + edges (vertex names): ## [1] Greg -&gt;Maria Greg -&gt;Mark Greg -&gt;Lexi Greg -&gt;Grace Greg -&gt;Nick ## [6] Maria-&gt;Mark Maria-&gt;Lexi Maria-&gt;Grace Maria-&gt;Nick Mark -&gt;Nick ## [11] Lexi -&gt;Nick The first line - which begins with IGRAPH DN - tells us moneyNetwork is an igraph object and a directed network (DN), with N nodes and E edges. The next line tells us some attributes of the nodes and edges network. At the moment, it only has the attribute “name” for the vertices (v/c). We can look at the values of the “name” attribute with the V()$ function. V(moneyNetwork)$name ## [1] &quot;Greg&quot; &quot;Maria&quot; &quot;Mark&quot; &quot;Lexi&quot; &quot;Grace&quot; &quot;Nick&quot; Finally, the last part gives us a snapshot of the edges present in the network, most of which are omitted. We can visualize the network using the plot() function. plot(moneyNetwork) The default visualization is pretty ugly… In the next section, we will learn how to improve the aesthetics of our network visualizations. "]
]
